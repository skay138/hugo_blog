[{"content":"스프링캠프 2019[Track 2 Mini-Session]: 자바에서 null을 안전히 다루는 방법(박성철) 영상을 시청하며 정리한 글입니다.\n#\rnull에 대해서\r객체 지향의 시초가 된 논문 Record Handing - C. A. R. Hoare에서 null에 대해 다음과 같이 정의했습니다.\n두 객체가 서로 참조 관계에 있을 때, 한 객체가 다른 객체를 참조할 일이 없는 경우\nFor a partial functional relationship, there may be an x for which there is no y appropriately related to it.\n부분적인 함수적 관계의 경우, 어떤 x에 대해 그와 적절하게 관련된 y가 없을 수 있습니다.\nAll the relationships introduced above for persons are in fact partial, since there will be persons who have no offspring, and persons who have no elder brother or sister; and in any finite collection of persons, there must be at least one who has no father.\n위에서 소개된 모든 인간 관계는 사실 부분적인 것입니다. 왜냐하면 후손이 없는 사람들이나 형제가 없는 사람들이 있기 때문입니다. 그리고 어떤 유한한 인간 집합에서도 적어도 한 명의 아버지가 없는 사람이 있을 겁니다.\nIn order to meet this problem, a special null value is provided for reference variables and fields.\n이 문제를 해결하기 위해, 참조 변수와 필드를 위해 특별한 널(null) 값이 제공됩니다.\nIf a field of a record is given this value, it usually indicates that the functional relationship represented by that field is not defined (or not yet defined) for that record; and that it is therefore a partial rather than total functional relationship.\n만약 레코드의 필드가 이 값으로 설정된다면, 보통은 해당 필드에 의해 표현된 함수적 관계가 해당 레코드에 대해 정의되지 않았음(또는 아직 정의되지 않았음)을 나타내며, 따라서 부분적이고 전체적이 아닌 함수적 관계임을 의미합니다.\n(2.2 Partial Functional Relationships p.9 참고)\n이는 객체지향 언어에서 특별한 값이 없음을 나타내기 위해 도입했고 이 값을 사용하려고 할 때 오류를 내도록 설계된 것입니다.\n하지만 이로 인해 모든 레퍼런스는 값이 있거나 null인 상황이 되어버리며, 프로그래머가 null을 항상 체크해야하는 번거로움이 생겼습니다.\nJava에서의 null\n의미가 모호하다. 초기화되지 않음 정의되지 않음 값이 없음 null이라는 값이 있음 모든 참조의 기본값이 null이며, null이 가능함. 조사에 따르면, 1000여개의 어플리케이션의 소프트웨어 결함이 Native Crash(161)를 제외하면 nullPointer Exception(149)이 많았다고 합니다.\n따라서 null을 안전하게 다루는 것이 중요합니다.\n#\rnull을 안전하게 다루는 방법\r어떻게 프로그래밍을 하는 게 좋을지에 대한 원칙과 가이드(중요)\n#\r단정문(assertion)\r1 2 assert 식1 ; assert 식1 : 식2; 부울식인 식1이 거짓이면 AssertionError 발생 식2는 AssertionError에 포함될 상세 정보를 만드는 생성식 -enableassertions 또는 -ea 옵션으로 활성화 1 2 3 4 5 private void setRefreshInterval(int interval) { assert interval \u0026gt; 0 \u0026amp;\u0026amp; interval \u0026lt;= 1000/MAX_REFRESH_RATE : interval; // 이어서 작성 } 단, 공개 메서드에는 사용하지 말아야 함.\n기본이 disable이기에 사용자를 알 수 없는 API등에서는 사용하면 안됨(운영에서 무시됨)\n#\rjava.util.Objects\rJava 8\n1 2 3 4 5 - isnull(Object obj) - nonnull(Object obj) - requireNonnull(T obj) - requireNonnull(T obj, String message) - requireNonnull(T obj, Supplier\u0026lt;String\u0026gt; messageSupplier) Java 9\n1 2 - requireNonnullElse(T obj, T defaultObj) - requireNonnullElseGet(T obj, Supplier\u0026lt;? extends T\u0026gt; Supplier) #\rjava.util.Optional\rOptional - The Mother of All Bikesheds: Stuart Marks\nRule #1: Never, ever, use null for an Optional variable or return value.\n절대로 Optional 변수와 반환값에 null을 사용하지 말라.\nRule #2: Never use Optional.get() unless you can prove that the Optional is present.\nOptional에 값이 들어 있다는 걸 확신하지 않는한 Optional.get()을 쓰지 말라.\n이는 결국 No Element Exception으로 돌아온다.\nRule #3: Prefer alternatives to Optional.isPresent() and Optional.get().\nOptional.isPresent()와 Optional.get()이외의 API를 가능한 사용하라.\nOptional.get()을 사용하기 위해 isPresent()를 호출하는 것은 null checking과 똑같다.\n영상에서 소개하는 추천 메서드들은 아래와 같습니다.\norElse(), orElseGet(), orElseThrow()\nmap()\n1 2 3 Optional\u0026lt;Customer\u0026gt; opt = custList.stream().filter(c -\u0026gt; c.getID() == custID).findFirst(); // return opt.isPresent() ? opt.get().getName() : \u0026#34;Unknown\u0026#34;; return opt.map(Customer::getName).orElse(\u0026#34;Unknown\u0026#34;); filter()\n1 2 Optional\u0026lt;Obj\u0026gt; obj = config.parent(); config.parent().filter(config -\u0026gt; config == this.config()).orElseThrow(Exception::new); ifPresent()\n1 2 3 4 5 6 7 Optional\u0026lt;Task\u0026gt; oTask = getTask(...); if (oTask.isPresent()){ executor.runTask(oTask.get()); } // use: getTask(...).ifPresent(executor::runTask); Stream of Optional\n1 2 3 4 5 6 7 8 9 10 11 12 // Java8 List\u0026lt;Customer\u0026gt; list1 = custIDlist.stream(). map(Customer::findByID) .filter(Optional::isPresent) .map(Optional::get) .collect(Collectors.toList()); // Java9 List\u0026lt;Customer\u0026gt; list = custIDlist.stream() .map(Customer::findByID) .flatMap(Optional::stream) .collect(Collectors.toList()); Rule #4: It\u0026rsquo;s generally a bad idea to create an Optional for the specific purpose of chaining methods from it to get a value.\n값을 가져오기 위해 Optional을 생성하여 메서드를 연결하는 것은 일반적으로 좋은 방법이 아니다.\nMethod Chaining\n1 2 3 4 5 6 7 8 9 // BAD String process(String s) { return Optional.ofNullable(s).orElseGet(this::getDefault); } // GOOD String process(String s) { return (s != null) ? s : getDefault(); } Rule #5: If an Optional chain is nested or has an intermediate result of Optional\u0026lt;Optional\u0026gt;, it\u0026rsquo;s probably too complex.\nAvoiding If-Statements is Cool, But\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Optional\u0026lt;BigDecimal\u0026gt; first = getFirstValue(); Optional\u0026lt;BigDecimal\u0026gt; second = getSecondValue(); // Add first and second, treating empty as zero, returning as Optional of the sum, // unless BOTH are empty, in which case return an empty Optional. Optional\u0026lt;BigDecimal\u0026gt; result = Stream.of(first, second) .filter(Optional::isPresent) .map(Optional::get) .reduce(BigDecimal::add); // clever but... Optional\u0026lt;BigDecimal\u0026gt; results = first.map(b -\u0026gt; second.map(b::add).orElse(b)) .map(Optional::of).orElse(second); // Not the shortest, but is it the clearest? Optional\u0026lt;BigDecimal\u0026gt; result; if(!first.isPresent() \u0026amp;\u0026amp; !second.isPresent()) { result = Optional.empty(); } else { result = Optional.of(first.orElse(ZERO).add(second.orElse(ZERO))); } Optional로 값을 처리하는 중에 그 안에 중간값을 처리하기 위해 또 다른 Optional이 사용되면 너무 복잡해진다.\nRule #6: Avoid using Optional in fields, method parameters, and collections.\nOptional을 필드, 메서드 매개변수, 집합 자료형에 쓰지 말라.\nRule #7: Avoid using identity-sensitive operations on Optionals.\n집합 자료형(List, Set, Map)을 감싸는 데 Optional을 쓰지 말고 빈 집합을 사용하라.\nOptional은 반환값으로만 사용하며, 직렬화가 안된다는 사실에 주의하자.\n#\rnull 잘 쓰는 법\rAPI(매개변수, 반환값)에 null을 최대한 쓰지 말아라. 반환값은 Optional, null 객체, 빈값, 예외로 처리 매개변수는 명확한 메서드 추가 정의 사전 조건과 사후 조건을 확인하라: 계약에 의한 설계(design by contract) 보호절을 통한 사전 조건 확인, 다양한 편의 객체 활용 (상태와 같이) null의 범위를 지역(클래스, 메서드)에 제한하라. 초기화를 명확히 하라. null 잘 쓰는 법 1: API에 null을 최대한 쓰지 말아라\nnull로 지나치게 유연한 메서드를 만들지 말고 명시적인 메서드를 만들어라 null을 반환하지 말라 반환 값이 꼭 있어야 한다면 null을 반환하지 말고 예외를 던져라 빈 반환 값은 빈 컬렉션이나 \u0026ldquo;null 객체\u0026quot;를 활용하라 반환 값이 없을 수도 있다면 Optional을 반환하라 선택적 매개변수는 null 대신 다형성(메서드 추가 정의; overload)을 사용해서 표현하라 null 잘 쓰는 법 2: 계약에 의한 설계(Design by Contract)\nWhen quality is pursued, productivity follows - K. Fujino\nAPI 규약을 소비자와 제공자 사이에 지켜야 할 엄격한 계약으로 여기는 설계 방법 형식적 규약 외에 사전 조건과 사후 조건과 유지 조건을 포함 베르트랑 마이어(Bertrand Meyer) - 에펠(Eiffel) 프로그래밍 언어 제작 개방-폐쇄 원칙의 상위 개념 개방-폐쇄 원칙이란 소프트웨어 구성 요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서 개방되어야 하지만, 변경에 대해서는 폐쇄되어야 한다는 의미이다. 즉, 변하는 것은 변하기 쉽게, 변하지 않는 것은 변하는 것에 영향을 받지 않게 설계하는 것을 의미\n요약하면, null이 아니여야하는데 null이 들어오는 경우를 확인해야 한다는 겁니다.\nnull 잘 쓰는 법 3: null의 범위를 지역에 제한하라\nOOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. - Alan Kay\n기본 문제 해결 원칙: 큰 문제는 제어 가능한 작은 문제로 나누어 정복하고 다시 통합한다. 상태도 비슷하게 null도 지역적으로 제한할 경우 큰 문제가 안된다. 클래스와 메서드를 작게 만들어라. 설계가 잘 된 코드에서는 null의 위험도 약해진다. 상태를 클래스와 메서드 안에서만 핸들링하고 다른 곳에서 side effect가 없다면 품질문제가 일어날 확률은 낮습니다.\nnull 잘 쓰는 법 4: 초기화를 명확히 하라\n초기화 시점과 실행 시점이 겹치지 않아야 한다. 실행 시점엔 초기화되지 않은 필드가 없어야 한다. 실행 시점에 null인 필드는 초기화되지 않았따는 의미가 아닌, 값이 없다는 의미여야 한다. 객체 필드의 생명주기는 모두 객체의 생명주기와 같아야 한다. 지연 초기화(lazy initialization) 필드의 경우 팩토리 메서드로 null 처리를 캡슐화 하라. #\rnull이 안전하다고 보장해주는 도구\r#\rCheckerFramework\rnull 안정성 확인 @nullable, @Nonnull, @Polynull Map 키, 잠금, 순차 자료형(배열, 리스트 등) 색인값, 정규식, 문자열 형식, 단위 등 다수 확인 기능 제공 자작 확인 기능 추가 가능 특정 환경이나 IDE 독립적 #\r기본 null 정책\r과도한 어노테이션 사용 예방 기본 @Nonnull(필드, 매개변수, 반환값 등) 예외적 @nullable(지역 변수, 타입 캐스트 등) 패키지, 클래스 수준 정책 설정 @DefaultQualifier 예시 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Address{ public final String address1; public final @Nullable String address2; public final String zipcode; public final String city; public final String country; private Address(String address1, @Nullable String address2, String zipcode, String city, String country){ // 이어서 작성 } public static Address of(String address1, String zipcode, String city, String country){ return new Address(address1, null, zipcode, city, country); } } ","date":"2024-04-25T04:03:19.544Z","image":"http://localhost:1313/cover/java.png","permalink":"http://localhost:1313/article/null-in-java/","title":"자바(Spring)에서 null 핸들링하기"},{"content":"게시판을 구현하다보면 첨부파일 기능이 필요한 경우가 있습니다. 현재 진행중인 Spring 기반 프로젝트 버전과 맞는 첨부파일 핸들링을 해보며 관련 내용을 정리해보려고 합니다.\n선요약 : NIO API를 이용하거나 전통적인 IO API를 이용할 수 있습니다.\n#\r테이블 구성\r게시글 하나당 하나의 첨부파일만 업로드한다면 게시글 테이블 하나로도 구현이 가능하겠지만, 여러개의 첨부파일을 올리고 싶다면 첨부파일 테이블을 따로 구성해야 합니다.\n저는 게시판 테이블의 이름을 HappyBoard라 정하였고, 이에 따라 HappyBoardAtfi라는 첨부파일 관리 테이블을 만들었습니다.\n두 테이블에는 ATGP_SN(그룹파일번호) 컬럼을 두어 연결을 했습니다.\n첨부파일 테이블의 구성은 다음과 같습니다.\nATGP_SN : 그룹파일번호 ATFI_SN : 첨부파일번호(PK) ATFI_URL : 첨부파일 저장 경로 ATFI_SF_NAME : 첨부파일 저장 이름 ATFI_OG_NAME : 첨부파일 원본 이름 ATFI_EXT : 첨부파일 확장자명 #\r파일 업로드\r#\rNIO.2 API (JDK7)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public String happyFileUpload(MultipartFile file, String happyAtgpSn) throws Exception { String filePath = \u0026#34;happyBoard/atch/\u0026#34;; String fileExt = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\u0026#34;.\u0026#34;) + 1).toLowerCase(); String fileName = \u0026#34;happy\u0026#34; + \u0026#34;_\u0026#34; + System.nanoTime() + \u0026#34;.\u0026#34; + fileExt; Path happyFilePath = Paths.get(filePath, fileName); // 원본파일명이 없으면 패스 if (file.getOriginalFilename().equals(\u0026#34;\u0026#34;)) { happyAtgpSn = \u0026#34;400\u0026#34;; return happyAtgpSn; } try { //폴더 경로가 없다면 생성 File chkDir = new File(filePath); if (!chkDir.exists()) { chkDir.mkdirs(); } // 파일 데이터가 있다면 try (InputStream inputStream = file.getInputStream()){ // 파일 저장 Files.copy(inputStream, happyFilePath, StandardCopyOption.REPLACE_EXISTING); // 파일 정보 객체에 저장 HappyBoardAtfiVO happyBoardAtfiVO = new HappyBoardAtfiVO(); happyBoardAtfiVO.setHappyAtgpSn(happyAtgpSn); // 첨부파일 그룹 일련번호 happyBoardAtfiVO.setHappyAtfiOgName(file.getOriginalFilename()); // 첨부파일 원본명 happyBoardAtfiVO.setHappyAtfiSfName(fileName); // 첨부파일 저장명 happyBoardAtfiVO.setHappyAtfiExt(fileExt); // 첨부파일 확장자명 happyBoardAtfiVO.setHappyAtfiUrl(filePath); // 첨부파일 저장 경로 // 첨부파일 정보 등록 happyAtgpSn = mypageService.insertHappyAtfiInfo(happyBoardAtfiVO); } } catch (NullPointerException np) { np.printStackTrace(); happyAtgpSn = \u0026#34;400\u0026#34;; } catch (IOException ie) { ie.printStackTrace(); happyAtgpSn = \u0026#34;400\u0026#34;; } catch (Exception e) { e.printStackTrace(); happyAtgpSn = \u0026#34;400\u0026#34;; } return happyAtgpSn; } 위 메서드가 정상적으로 종료되어 happyAtgpSn을 return한다면 서버에 첨부파일이 저장되고, 첨부파일 테이블에도 관련 정보가 저장됩니다. 이후 happyAtgpSn을 게시글 데이터에 추가하여 게시글 테이블에 해당 게시글을 등록합니다(코드는 생략).\nFiles.copy()에서 CopyOption을 설정할 수 있습니다.\nStandardCopyOption은 3가지를 제공합니다.\nREPLACE_EXISTING : 기존 파일이 존재하는 경우 해당 파일을 대체합니다. COPY_ATTRIBUTES : 파일의 속성을 새 파일로 복사합니다. ATOMIC_MOVE : 원자적 이동(파일 이동 작업을 끝까지 보장). #\rIO API (Before JDK7)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public String happyFileUpload(MultipartFile file, String happyAtgpSn) throws Exception { String filePath = \u0026#34;happyBoard/atch\u0026#34;; //확장자명 가져오기 String fileExt = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\u0026#34;.\u0026#34;) + 1).toLowerCase(); String fileName = \u0026#34;happy\u0026#34; + \u0026#34;_\u0026#34; + System.nanoTime() + \u0026#34;.\u0026#34; + fileExt; // 저장할 경로의 파일객체를 생성(transferTo 메서드에 사용) File happyFile = new File(filePath + fileName); // 원본파일명이 존재하는 경우 if (!\u0026#34;\u0026#34;.equals(file.getOriginalFilename())) { happyAtgpSn = \u0026#34;400\u0026#34;; return happyAtgpSn; } try { // 파일 경로가 없다면 생성 File chkDir = new File(filePath); if (!chkDir.exists()) { chkDir.mkdirs(); } // 임시 파일 저장 경로로 이동(서버에 저장) file.transferTo(happyFile); // 파일 정보 객체에 저장 HappyBoardAtfiVO happyBoardAtfiVO = new HappyBoardAtfiVO(); happyBoardAtfiVO.setHappyAtgpSn(happyAtgpSn); // 첨부파일 그룹 일련번호 happyBoardAtfiVO.setHappyAtfiOgName(file.getOriginalFilename()); // 첨부파일 원본명 happyBoardAtfiVO.setHappyAtfiSfName(fileName); // 첨부파일 저장명 happyBoardAtfiVO.setHappyAtfiExt(fileExt); // 첨부파일 확장자명 happyBoardAtfiVO.setHappyAtfiUrl(filePath); // 첨부파일 저장 경로 // 첨부파일 정보 DB에 등록 happyAtgpSn = mypageService.insertHappyAtfiInfo(happyBoardAtfiVO); } catch (NullPointerException np) { np.printStackTrace(); happyFile.delete(); happyAtgpSn = \u0026#34;400\u0026#34;; } catch (IOException ie) { ie.printStackTrace(); happyFile.delete(); happyAtgpSn = \u0026#34;400\u0026#34;; } catch (Exception e) { e.printStackTrace(); happyFile.delete(); happyAtgpSn = \u0026#34;400\u0026#34;; } return happyAtgpSn; } JAVA IO API를 이용하여 업로드 기능을 구현할 수도 있습니다.\n#\r파일 다운로드\r파일 다운로드를 위한 방법으로 스트림 방식과 URL 제공 방식이 있습니다.\n스트리밍 방식 : 데이터를 outputStream에 담아 전송 URL 제공 방식 : 파일이 저장되어 있는 경로를 제공하여 브라우저에서 다운로드 #\r스트림 방식\r#\rNIO.2 API (JDK7)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public void happyFileDownload(HttpServletRequest request, HttpServletResponse response) throws Exception { String happyAtfiSn = request.getParameter(\u0026#34;happyAtfiSn\u0026#34;); String happyAtgpSn = request.getParameter(\u0026#34;happyAtgpSn\u0026#34;); String happyAtfiOgName = request.getParameter(\u0026#34;happyAtfiOgName\u0026#34;); String happyAtfiSfName = request.getParameter(\u0026#34;happyAtfiSfName\u0026#34;); // 요청 파일명 확인 if (happyAtfiSfName == null) { return; } String filePath = \u0026#34;happyBoard/atch/\u0026#34;; Path file = Paths.get(filePath, happyAtfiSfName); // 파일이 없다면 종료 if (!Files.exists(file) || !Files.isRegularFile(file)) { return; } // 브라우저에 따른 인코딩 String browser = request.getHeader(\u0026#34;User-Agent\u0026#34;); String encodedFileName = \u0026#34;\u0026#34;; // 브라우저 종류에 따른 파일명 인코딩 if (browser.contains(\u0026#34;MSIE\u0026#34;) || browser.contains(\u0026#34;Trident\u0026#34;) || browser.contains(\u0026#34;Chrome\u0026#34;)) { // 브라우저 확인 파일명 encodedFileName = URLEncoder.encode(happyAtfiOgName, \u0026#34;UTF-8\u0026#34;).replaceAll(\u0026#34;\\\\+\u0026#34;, \u0026#34;%20\u0026#34;).replace(\u0026#34;+\u0026#34;, \u0026#34;%20\u0026#34;); } else { encodedFileName = new String(happyAtfiOgName.getBytes(\u0026#34;UTF-8\u0026#34;), \u0026#34;ISO-8859-1\u0026#34;); } // response 타입 설정 response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + encodedFileName); response.setContentType(\u0026#34;application/octet-stream\u0026#34;); // 파일 response로 전송 Files.copy(file, response.getOutputStream()); } 일반적인 파일 다운로드 기능은 NIO API를 이용하여 파일 다운로드 기능을 구현할 수 있습니다.\n참고: Files.copy()는 8192byte의 버퍼 사이즈를 가집니다.\n#\rIO API (Before JDK7)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 File file = new File(filePath + happyAtfiSfName); // 중략 fis = new FileInputStream(file); bis = new BufferedInputStream(fis); so = response.getOutputStream(); bos = new BufferedOutputStream(so); byte[] data = new byte[2048]; int input = 0; // 버퍼에 데이터를 담아 없을 때까지 전송 while ((input = bis.read(data)) != -1) { bos.write(data, 0, input); bos.flush(); } NIO API가 나오기 전, 직접 stream을 열어 loop를 통해 전달하는 전통적인 방식입니다.\nFileInputStream과 ServletOutputStream만 이용해도 되지만 성능을 높이기 위해 Buffer를 붙입니다.\nFileInputStream: 이 클래스는 파일로부터 바이트 단위로 데이터를 읽어오는데 사용됩니다. 파일을 열고 그 내용을 읽어들일 때 주로 활용됩니다. BufferedInputStream: 이 클래스는 데이터를 읽어올 때 성능을 향상시키기 위해 사용됩니다. FileInputStream과 같이 사용되며, 데이터를 버퍼에 저장해두고 필요할 때 버퍼로부터 읽어오는 방식으로 동작합니다. 이는 입출력 작업을 보다 효율적으로 수행할 수 있도록 도와줍니다. ServletOutputStream: 이 클래스는 서블릿에서 클라이언트로 데이터를 보낼 때 사용됩니다. 서블릿 컨테이너에서 제공되며, HTTP 응답의 출력 스트림을 나타냅니다. 클라이언트로 데이터를 보내기 위해 사용됩니다. BufferedOutputStream: 이 클래스는 데이터를 쓸 때 성능을 향상시키기 위해 사용됩니다. ServletOutputStream과 같이 사용되며, 데이터를 버퍼에 저장해두고 필요할 때 버퍼의 내용을 출력하는 방식으로 동작합니다. 이는 입출력 작업을 보다 효율적으로 수행할 수 있도록 도와줍니다. 이렇게 설정된 스트림들은 파일의 내용을 읽어들여 클라이언트에게 전송하는 데 사용됩니다. FileInputStream과 BufferedInputStream은 파일에서 데이터를 읽어오고, ServletOutputStream과 BufferedOutputStream은 클라이언트로 데이터를 전송합니다.\n그 밖에\nApache Commons IO Guava(Google) 등을 이용하여 구현할 수도 있습니다.\n#\r성능 비교\rNIO API와 IO API의 파일 처리 속도를 테스트했습니다.\n81.4MB 크기의 PDF 파일로 테스트했으며 괄호는 buffer 크기입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 - NIO API(8192) 메서드 실행 시간: 284밀리초 메서드 실행 시간: 228밀리초 메서드 실행 시간: 219밀리초 메서드 실행 시간: 197밀리초 메서드 실행 시간: 206밀리초 - JAVA IO(2048) 메서드 실행 시간: 1000밀리초 메서드 실행 시간: 594밀리초 메서드 실행 시간: 887밀리초 메서드 실행 시간: 730밀리초 메서드 실행 시간: 895밀리초 - JAVA IO(4096) 메서드 실행 시간: 288밀리초 메서드 실행 시간: 281밀리초 메서드 실행 시간: 359밀리초 메서드 실행 시간: 360밀리초 메서드 실행 시간: 570밀리초 - JAVA IO(8192) 메서드 실행 시간: 448밀리초 메서드 실행 시간: 343밀리초 메서드 실행 시간: 312밀리초 메서드 실행 시간: 351밀리초 메서드 실행 시간: 341밀리초 NIO API의 평균값이 더 좋은 성능을 보이며 이는 buffer 크기 차이는 아닙니다.\nUsing NIO.2 can significantly increase file copying performance since the NIO.2 utilizes lower-level system entry points.\n이는 NIO API의 files.copy() 메소드는 Direct Buffer를 사용하여 데이터를 전송하기 때문에 뛰어난 퍼포먼스를 보여준다고 합니다.\nDirect Buffer는 JVM 힙 메모리 외부에 위치하므로, 데이터 복사 시 메모리 복사 오버헤드가 줄어듭니다.\nFiles.copy() 메서드 중\n1 2 3 4 5 6 7 8 public static long copy(Path source, OutputStream out) throws IOException { // ensure not null before opening file Objects.requireNonNull(out); try (InputStream in = newInputStream(source)) { return copy(in, out); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public InputStream newInputStream(Path path, OpenOption... options) throws IOException { if (options.length \u0026gt; 0) { for (OpenOption opt: options) { // All OpenOption values except for APPEND and WRITE are allowed if (opt == StandardOpenOption.APPEND || opt == StandardOpenOption.WRITE) throw new UnsupportedOperationException(\u0026#34;\u0026#39;\u0026#34; + opt + \u0026#34;\u0026#39; not allowed\u0026#34;); } } return Channels.newInputStream(Files.newByteChannel(path, options)); } 내부 코드를 보면 newInputStream()을 호출하는데 해당 메서드에서 Channel을 이용하는 것을 확인할 수 있습니다.\n#\r채널\r입출력 채널(I/O channel)은 프로세서가 다른 일을 하지 못하는 문제를 해결하기 위해 개발되었습니다.\n채널은 중앙 처리 장치와 주변 장치의 동작을 분리시켜, 프로세서가 다른 작업을 수행할 수 있도록 합니다.\n채널은 주기억 장치에 직접 접근하여 정보를 저장하거나 검색할 수 있습니다.\n채널 방식을 이용할 때 다음과 같은 장점이 있습니다.\n양방향 통신 지원 채널 방식은 단일 채널로 양방향 입출력이 가능합니다. 이를 통해 데이터 송수신을 동시에 처리할 수 있어 효율적입니다. 버퍼 메커니즘 활용 채널 방식은 버퍼를 사용하여 입출력 데이터를 관리합니다. 버퍼를 통해 데이터를 일시적으로 저장하고 관리할 수 있어, 프로세서가 다른 작업을 수행할 수 있습니다. 프로세서 활용도 향상 채널 방식은 프로세서와 주변 장치의 동작을 분리시켜, 프로세서가 다른 작업을 수행할 수 있도록 합니다. 이를 통해 프로세서의 활용도가 높아져 전체적인 시스템 성능이 향상됩니다. 비동기 처리 지원 채널 방식은 비동기 입출력을 지원하여, 데이터 전송 중에도 다른 작업을 수행할 수 있습니다. 이를 통해 전체적인 시스템 응답성이 향상됩니다. 따라서 채널 방식은 버퍼 메커니즘, 양방향 통신, 비동기 처리 등의 기능을 통해 스트림 방식보다 성능이 우수합니다. 이는 프로세서의 활용도를 높이고 전체적인 시스템 성능을 향상시킬 수 있습니다.\n#\r결론\rNIO API의 files.copy() 메소드는 Direct Buffer 사용, FileChannel 활용, 비동기 처리 지원 등의 기능을 통해 기존 java.io 방식보다 더 높은 성능을 발휘할 수 있다고 정리할 수 있습니다.\n#\rURL 제공 방식\r1 2 3 4 5 6 7 8 9 @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/files/**\u0026#34;) .addResourceLocations(\u0026#34;file:///your/path/location\u0026#34;); } } url 지정(localhost:8080/files/)\n1 registry.addResourceHandler(\u0026#34;/files/**\u0026#34;) 리소스 파일의 실제 주소 설정\n1 2 3 4 5 6 7 8 // 리눅스 경우 root에서 시작하는 폴더 경로 지정 할 경우 .addResourceLocations(\u0026#34;file:///usr/download/\u0026#34;) // 리소스 템플릿 경로를 지정할 경우 .addResourceLocations(\u0026#34;classpath:/templates/\u0026#34;, \u0026#34;classpath:/static/\u0026#34;) // 윈도우에서 실행 시 다음과 같은 형태로 드라이브 문자 포함 경로 지정 .addResourceLocations(\u0026#34;file:///C:/~/\u0026#34;) 파일 리소스의 경로와 URL 경로를 맵핑하여 파일에 접근할 수 있습니다.\n경로를 통해 정상적으로 다운로드가 가능한 것을 확인했습니다.\n#\r파일 삭제\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public int happyFileDel(String happyAtfiSfName, String happyAtfiSn) throws Exception { int code = 400; try { String filePath = \u0026#34;happyBoard/atch\u0026#34;; File happyFile = new File(filePath + happyAtfiSfName); // 첨부파일 삭제 boolean progress = happyFile.delete(); if (progress) { // 첨부파일 정보 삭제 mypageService.happyAtfiDelete(happyAtfiSn); code = 200; } } catch (NullPointerException np) { np.printStackTrace(); code = 400; return code; } catch (IOException ie) { ie.printStackTrace(); code = 400; return code; } catch (Exception e) { e.printStackTrace(); code = 400; return code; } return code; } 파일 삭제의 경우, 서버에 올라간 파일을 삭제 후 DB테이블의 파일도 삭제를 해주셔야 합니다.\n해당 메서드를 파일삭제, 게시글 삭제 등 적절한 요청에 붙여서 사용했습니다.\n","date":"2024-04-11T08:03:19.544Z","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/sping-file-upload-download/","title":"Spring 파일 업로드와 다운로드"},{"content":"\r#\rHTTP 파라미터 방식\rPath 방식 URL에 포함된 파라미터를 받아오는 방식으로, 주로 GET요청에서 사용됩니다. api/data/{id}의 형태로 id를 전달하는 방식입니다. Query 방식 URL에 ?뒤의 문자열로 전달되는 데이터를 받습니다. POST 요청에서도 사용될 수 있지만, 보편적으로 GET요청에서 사용됩니다. api/dada/?id=3의 형태로 id값을 전달하는 방식입니다. Body 방식 HTTP 요청의 body에 포함된 데이터를 받아오는 방식입니다. 주로 POST, PUT 요청에서 사용됩니다. 데이터의 형태는 JSON이 일반적입니다. #\rSpring에서의 적용\r#\r@PathVariable(Path 방식)\rPath 방식을 처리하기 위해 @PathVariable 어노테이션을 사용합니다.\n예를 들어, URL이 http://example.com/api/data/John/30와 같이 요청되었다고 가정해봅시다. 이때 경로에 포함된 name과 age 값을 받아와서 처리하는 코드는 다음과 같습니다:\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/api/data/{name}/{age}\u0026#34;) public String getData(@PathVariable String name, @PathVariable int age) { return \u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age; } } #\r@RequestParam(Query 방식)\rQuery 방식을 처리하기 위해 @RequestParam 어노테이션을 사용합니다.\n예를 들어, URL이 http://example.com/api/data?name=John\u0026amp;age=30와 같이 요청되었다고 가정해봅시다. 이때 name과 age 파라미터 값을 받아와서 처리하는 코드는 다음과 같습니다:\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/api/data\u0026#34;) public String getData(@RequestParam String name, @RequestParam int age) { return \u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age; } } #\r데이터가 여러개인 경우\r한 종류의 파라미터의 데이터가 여러개일 경우, 리스트나 배열을 이용할 수 있습니다.\n예를 들어, URL이 http://example.com/api/data?names=John\u0026amp;names=Alice\u0026amp;names=Bob와 같이 요청되었다면, names 배열에는 \u0026ldquo;John\u0026rdquo;, \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Bob\u0026quot;이 포함될 것입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController public class MyController { @GetMapping(\u0026#34;/api/data\u0026#34;) public String getData(@RequestParam List\u0026lt;String\u0026gt; names) { // @RequestParam String[] names 로 작성하면 배열로 처리 return \u0026#34;Received names: \u0026#34; + names.toString(); } } 파라미터의 종류가 여러개일 경우, @RequestParam를 각각 사용하여 받아올 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/api/data\u0026#34;) public String getData( @RequestParam String name, @RequestParam int age, @RequestParam(required = false) String city // 선택적 파라미터 ) { // 각각의 파라미터 값을 처리 return \u0026#34;Received data: name=\u0026#34; + name + \u0026#34;, age=\u0026#34; + age + \u0026#34;, city=\u0026#34; + city; } } #\r@RequestBody(Body 방식)\rBody 방식을 처리하기 위해 @RequestBody를 사용합니다.\nJSON 형식의 데이터를 처리하는 코드 예시입니다.\n1 2 3 4 { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @PostMapping(\u0026#34;/api/data\u0026#34;) public String processData(@RequestBody MyData data) { return \u0026#34;Received data: \u0026#34; + data.toString(); } public static class MyData { private String name; private int age; // Getters and setters @Override public String toString() { return \u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age; } } } 별도의 클래스를 만들고 싶지 않다면, String이나 Map\u0026lt;String, Object\u0026gt;타입을 통해 데이터를 받아올 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import java.util.Map; @RestController public class MyController { @PostMapping(\u0026#34;/api/data\u0026#34;) public String processData(@RequestBody Map\u0026lt;String, Object\u0026gt; requestBody) { // 요청 본문의 데이터를 Map으로 받아옴 // requestBody를 이용하여 원하는 처리 수행 return \u0026#34;Received data: \u0026#34; + requestBody.toString(); } } #\r번외\r#\r@ModelAttribute\rForm형태의 HTTP Body와 요청 파라미터를 객체에 바인딩하고, return 시 자동으로 view로 전달됩니다.\n@ModelAttribute 어노테이션은 스프링 MVC 컨트롤러 메서드에서 사용되며, 해당 메서드의 파라미터나 리턴 값에 사용됩니다. 이 어노테이션은 모델 객체를 생성하거나 수정하여 해당 모델 객체를 뷰로 전달하는 데 사용됩니다.\n@ModelAttribute 어노테이션이 적용된 파라미터는 스프링 MVC에서 자동으로 모델에 추가됩니다. 이 모델 객체는 컨트롤러 메서드가 실행되는 동안 사용되며, 해당 메서드가 뷰를 반환할 때 자동으로 뷰에 전달됩니다.\n@ModelAttribute 어노테이션이 적용된 메서드는 컨트롤러 클래스 내에 위치하며, 주로 해당 컨트롤러에서 사용하는 공통 모델 객체를 초기화하거나 수정하는 데 사용됩니다.\n다음은 @ModelAttribute 어노테이션의 간단한 예시 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller public class MyController { @ModelAttribute(\u0026#34;user\u0026#34;) public User getDefaultUser() { // 기본 사용자 정보를 초기화하여 모델에 추가 User user = new User(); user.setUsername(\u0026#34;guest\u0026#34;); user.setEmail(\u0026#34;guest@example.com\u0026#34;); return user; } @RequestMapping(value = \u0026#34;/profile\u0026#34;, method = RequestMethod.GET) public String showProfile() { // profile.jsp와 같은 뷰로 포워딩하며 모델에 추가된 \u0026#34;user\u0026#34; 객체를 전달 return \u0026#34;profile\u0026#34;; } } 위의 코드에서는 @ModelAttribute 어노테이션이 적용된 getDefaultUser() 메서드를 정의하여 \u0026ldquo;user\u0026quot;라는 이름으로 기본 사용자 정보를 초기화하고 모델에 추가합니다. 그리고 showProfile() 메서드에서는 \u0026ldquo;/profile\u0026rdquo; 엔드포인트에 대한 GET 요청을 처리하고, \u0026ldquo;profile.jsp\u0026quot;와 같은 뷰로 포워딩하면서 모델에 추가된 \u0026ldquo;user\u0026rdquo; 객체를 전달합니다. 이렇게 하면 뷰에서는 \u0026ldquo;user\u0026rdquo; 객체를 사용하여 사용자 정보를 표시할 수 있습니다.\n@RequestMapping 어노테이션이 붙은 메서드의 파라미터 안에 @ModelAttribute 어노테이션이 선언되면 해당 메서드의 실행 전에 자동으로 모델 객체가 생성되어 파라미터로 전달됩니다. 이렇게 전달된 모델 객체는 컨트롤러 메서드 내에서 사용되거나 수정될 수 있으며, 최종적으로 뷰로 전달됩니다.\n다음은 @RequestMapping 어노테이션이 붙은 메서드의 파라미터 안에 @ModelAttribute 어노테이션이 선언된 예시 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller public class MyController { @RequestMapping(value = \u0026#34;/profile\u0026#34;, method = RequestMethod.GET) public String showProfile(@ModelAttribute(\u0026#34;user\u0026#34;) User user) { // \u0026#34;/profile\u0026#34; 엔드포인트에 대한 GET 요청을 처리하면서 // \u0026#34;user\u0026#34; 모델 객체가 생성되어 파라미터로 전달됨 // 이후 로직에서 \u0026#34;user\u0026#34; 객체를 사용할 수 있음 return \u0026#34;profile\u0026#34;; } @ModelAttribute(\u0026#34;user\u0026#34;) public User getDefaultUser() { // 기본 사용자 정보를 초기화하여 모델에 추가 User user = new User(); user.setUsername(\u0026#34;guest\u0026#34;); user.setEmail(\u0026#34;guest@example.com\u0026#34;); return user; } } 위의 코드에서 showProfile() 메서드의 파라미터에 @ModelAttribute(\u0026quot;user\u0026quot;) User user가 선언되어 있습니다. 이렇게 하면 스프링 MVC는 getDefaultUser() 메서드에서 반환한 기본 사용자 정보를 초기화한 후 모델에 추가하고, 이 모델 객체를 showProfile() 메서드의 파라미터로 전달합니다. 그러면 showProfile() 메서드 내에서는 user 객체를 사용하여 사용자 정보를 처리할 수 있습니다.\n#\rModel과의 차이점\r@ModelAttribute: 해당 어노테이션이 적용된 메서드는 컨트롤러 내에서 모델 객체를 초기화하거나 수정하고, 이를 컨트롤러 메서드의 파라미터로 전달합니다. 이렇게 전달된 모델 객체는 뷰에서 사용할 수 있습니다.\nModel: Model 객체는 컨트롤러 메서드에서 사용되며, 컨트롤러 메서드가 뷰로 전달할 데이터를 설정하는 데 사용됩니다. 메서드에서 Model 객체에 데이터를 추가하면, 이 데이터는 뷰로 전달되어 화면에 표시될 수 있습니다.\n두 가지 방식 모두 최종적으로는 뷰에 데이터를 전달하여 클라이언트에게 보여지도록 합니다. 따라서 이들은 모두 뷰로 전달한다는 공통된 목적을 가지고 있습니다.\n#\r@RequestBody와의 차이점\r@ModelAttribute: Form형태를 제외하면, HTTP 요청의 바디에 있는 데이터를 직접 처리하지 않습니다. 대신에 컨트롤러 메서드의 파라미터로 전달되는 모델 객체를 생성하거나 수정하는 데 사용됩니다. 주로 요청의 파라미터나 쿼리 스트링으로부터 데이터를 바인딩하여 모델 객체로 변환하는 데 사용됩니다.\n@RequestBody: HTTP 요청의 바디에 있는 데이터를 객체로 변환하여 컨트롤러 메서드에서 사용할 수 있도록 합니다. 주로 JSON(application/json)이나 XML 형식의 데이터를 전달할 때 사용됩니다. 이를 사용하면 HTTP 요청의 바디에 있는 데이터를 자동으로 해당 객체의 필드에 매핑하여 컨트롤러 메서드에서 사용할 수 있습니다.\n따라서 만약 HTTP 요청의 바디에 있는 데이터를 가져와야 한다면, @RequestBody를 사용해야 하며, @ModelAttribute는 주로 파라미터나 쿼리 스트링으로부터 데이터를 가져와서 모델 객체로 변환하는 데 사용됩니다.\njsp에서 . . . form.submit() 등 form형태로 데이터 전달 : @ModelAttribute ajax 등 json형태로 데이터 전달 : @RequestBody\n#\rAjax 타입 정리\r1 2 3 4 5 6 7 8 9 $.ajax({ type: \u0026#34;post\u0026#34;, //HTTP method url: \u0026#34;localhost:8080/api\u0026#34; //요청보낼 url, data : formData, //보낼 데이터 dataType: \u0026#34;json\u0026#34;, //수신할 데이터 타입 enctype: \u0026#34;multipart/form-data\u0026#34;, //데이터 전송 방식(데이터 인코딩 방식) contentType: false, //컨텐츠 타입(파일 업로드 시 false로 설정) processData: false, //데이터 처리 여부 (파일 업로드 시 false로 설정) cache: false, //캐시 사용 여부 주의: contentType는 설정하지 않을 시 \u0026ldquo;application/x-www-form-urlencoded\u0026quot;가 적용됩니다. 이때문에 @ResponseBody 어노테이션을 사용했을 때 415 ERROR가 발생할 수 있습니다. 다른 타입으로 \u0026ldquo;application/json\u0026quot;도 주로 사용됩니다.\n#\r@ResponseBody\r@ResponseBody 어노테이션은 스프링 컨트롤러 메서드에서 반환되는 객체를 HTTP 응답 본문으로 직접 변환하여 클라이언트에게 반환할 때 사용됩니다. 주로 JSON 또는 XML과 같은 데이터 형식으로 변환하여 클라이언트에게 전송됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.ResponseBody; @RestController public class MyController { @GetMapping(\u0026#34;/api/data\u0026#34;) @ResponseBody public String getData() { return \u0026#34;Hello, world!\u0026#34;; } } ","date":"2024-04-10T13:03:48.833Z","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/spring-http-param/","title":"Spring HTTP 파라미터 정리"},{"content":"개발 블로그를 시작하며 저만의 사이트를 가지고 싶었던 마음에 Hugo와 깃허브의 도움으로 호스팅하고 있었습니다.\n시간은 조금 걸리지만 제 입맛대로 조금씩 꾸며져가는 블로그를 보고 있으니 뿌듯한 마음이 들면서도, 글을 작성할 때 IDE를 사용하여 작성하다 보니 다음과 같은 불편함이 있었습니다..\nhugo 실행 및 preview 화면을 따로 확인해야 하는 번거로움 로컬 환경, 특히 세팅되어 있는 컴퓨터에서만 작성 가능함 이러한 사항들은 글을 작성하는 시간을 오래걸리게 할 뿐 아니라 글을 쓰려는 의지마저 저하시켰습니다. 이를 개선하기 위해 정보를 찾던 중 TinaCMS를 알게 되었고, 다음들을 적용시켜 게시글 관리를 하기로 했습니다.\nTinaCMS GitHub Action #\rTinaCMS\rTinaCMS는 컨텐츠를 관리하기 위한 프레임워크로 사이트 편집을 원활하게 할 수 있도록 도와줍니다. 제가 파악한 바로는 다음의 주요 기능들이 있습니다.\n게시글의 CRUD Tina Cloud를 통해 온라인 편집 컴포넌트를 연결하여 랜더링되는 화면에서 직접 편집 그 중 저는 2번까지만 적용하여 블로그를 관리하려고 합니다.\n#\rSetup TinaCMS\r블로그 디렉토리에서 다음 명령어를 실행합니다.\n1 npx @tinacms/cli@latest init public assets directory는 미디어를 관리하는 디렉토리를 묻는 것이기에, Hugo 기준 static을 입력하시면 됩니다.\n#\r컨텐츠 모델링하기\rTina를 이용하여 컨텐츠를 관리하기 위해, tina/config.ts파일에서 관련 설정을 해야합니다.\n저는 카테고리를 기반해 게시글 설정을 했습니다. 아래는 schema -\u0026gt; collections \u0026gt; 하위의 springboot collection 설정입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 { name: \u0026#34;springboot\u0026#34;, label: \u0026#34;SpringBoot\u0026#34;, path: \u0026#34;content/post/backend-studies/springboot\u0026#34;, defaultItem: () =\u0026gt; { return { image: \u0026#34;/cover/springboot.png\u0026#34;, title: \u0026#34;\u0026#34;, date: new Date(), slug: (values) =\u0026gt; values?.title ?.toLowerCase() .replace(/ /g, \u0026#39;-\u0026#39;), categories: [\u0026#39;Backend Studies\u0026#39;], tags: [\u0026#39;Spring Boot\u0026#39;], } }, ui: { filename: { // if disabled, the editor can not edit the filename readonly: true, // Example of using a custom slugify function slugify: (values) =\u0026gt; { // Values is an object containing all the values of the form. In this case it is {title?: string, topic?: string} return `${values?.title ?.toLowerCase() .replace(/ /g, \u0026#39;-\u0026#39;)}/index` }, }, }, fields: [ { type: \u0026#34;image\u0026#34;, name: \u0026#34;image\u0026#34;, label: \u0026#34;커버 이미지\u0026#34;, required: false, }, { type: \u0026#34;string\u0026#34;, name: \u0026#34;title\u0026#34;, label: \u0026#34;제목\u0026#34;, isTitle: true, required: true, }, { type: \u0026#34;string\u0026#34;, name: \u0026#34;slug\u0026#34;, label: \u0026#34;slug\u0026#34;, isTitle: false, required: false, description: \u0026#34;한글 포함 시 작성\u0026#34;, }, { type: \u0026#34;string\u0026#34;, name: \u0026#34;description\u0026#34;, label: \u0026#34;설명\u0026#34;, isTitle: false, required: false, }, { type: \u0026#34;datetime\u0026#34;, name: \u0026#34;date\u0026#34;, label: \u0026#34;작성일\u0026#34;, required: false, }, { name: \u0026#39;categories\u0026#39;, label: \u0026#39;카테고리\u0026#39;, type: \u0026#39;string\u0026#39;, list: true, options: [ { value: \u0026#39;Backend Studies\u0026#39;, label: \u0026#39;Backend Studies\u0026#39;, }, { value: \u0026#39;Algorithm\u0026#39;, label: \u0026#39;Algorithm\u0026#39;, }, { value: \u0026#39;Languages\u0026#39;, label: \u0026#39;Languages\u0026#39;, }, { value: \u0026#39;Tech Articles Reviews\u0026#39;, label: \u0026#39;Tech Articles Reviews\u0026#39;, }, { value: \u0026#39;Misc\u0026#39;, label: \u0026#39;Misc\u0026#39;, }, ], }, { type: \u0026#34;rich-text\u0026#34;, name: \u0026#34;body\u0026#34;, label: \u0026#34;Body\u0026#34;, isBody: true, }, { label: \u0026#34;Tags\u0026#34;, name: \u0026#34;tags\u0026#34;, type: \u0026#34;string\u0026#34;, list: true }, ], } name은 value, label은 Tina에서 보여줄 이름입니다.\npath는 게시글들이 존재하는 경로를 기입해주시면 됩니다.\ndefaultItem은 게시글 작성 시 자동으로 설정될 데이터입니다. 저는 커버 이미지, 제목 양식, 작성일, 카테고리, 태그 등을 설정했습니다.\nfields는 마크다운 파일의 설정입니다.\n더 자세한 설정은 이 곳에서 확인해보세요!\nui:filename은 제가 hugo의 stack테마를 기반으로 작성하고 있기 때문에, 이를 위해 그냥 filename.md로 저장하는 게 아닌, filename/index.md로 저장하게끔 수정했습니다. 현재 Media 핸들링을 위해 저도 디렉터리 구조의 변경을 고려하고 있으며, 참고만 하시면 될 것 같습니다.\n1 npx tinacms dev -c \u0026#34;hugo server -D -p 1313\u0026#34; 설정을 마친 후 서버를 실행한 뒤 localhost:1313/admin 으로 접속하면 Tina페이지를 볼 수 있습니다.\ncollection 선택 후 Create New 버튼을 클릭하게 되면 글 양식에 맞게 화면이 나오는 것을 볼 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 --- image: /cover/springboot.png title: \u0026#34;Messaging with Redis\u0026#34; description: using Spring Data Redis to publish and subscribe to messages sent with Redis. date: 2024-03-15T12:08:56.000Z categories: - Backend Studies tags: - Spring Boot --- ## What You Will Build `StringRedisTemplate`를 이용하여 메세지를 게시하고, `MessageListenerAdapter`를 이용하여 메세지를 가져오는 POJO를 구현해봅시다. 실제 작성 시 위와 같은 md파일이 생성됩니다.\nbody의 경우, md형식으로 작성하거나 미리보기의 형태로 글을 작성해볼 수 있습니다.\n다만 저는 hugo컴포넌트와 연결하지는 않았기 때문에 Hugo에서의 미리보기 형태는 아닙니다.\n#\rTina Cloud\rLocal에서의 실행이 문제 없이 된다면, 온라인으로도 편집하기 위해 Tina Cloud를 이용해봅시다.\nTina Cloud 계정 만들기 프로젝트 생성하기\n1. Site URLs은 호스팅될 주소를 입력해주세요(ex : https://skay138.github.io)\n2. Repository는 블로그에 대한 Repository를 설정해주세요(ex : https://github.com/skay138/skay138.github.io) Tina Cloud 설정이 끝났다면 Backend 구축을 해야합니다.\n1 npx @tinacms/cli init backend 커맨드를 실행하게 되면 tina/config.ts 파일이 수정되고, root 디렉토리에 .env가 추가될 겁니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Your hosting provider likely exposes this as an environment variable const branch = process.env.GITHUB_BRANCH || process.env.VERCEL_GIT_COMMIT_REF || process.env.HEAD || \u0026#34;main\u0026#34;; export default defineConfig({ branch, // Get this from tina.io clientId: process.env.TINA_PUBLIC_CLIENT_ID, // Get this from tina.io token: process.env.TINA_TOKEN, build: { outputFolder: \u0026#34;admin\u0026#34;, publicFolder: \u0026#34;static\u0026#34;, }, media: { tina: { mediaRoot: \u0026#34;\u0026#34;, publicFolder: \u0026#34;content/post\u0026#34;, }, }, 여기서 TINA_PUBLIC_CLIENT_ID가 기존에는 PUBLIC_TINA_CLINET_ID거나 다른 변수명일텐데 수정해 주세요!\n로컬에서 실행시킨다면 .env도 맞춰서 수정해주셔야 합니다.\nTINA_PUBLIC_CLIENT_ID : Tina Cloud의 Client ID TINA_TOKEN : Tina Cloud의 Tokens/Content(Read only) media의 경우\npublicFolder : assets을 관리하는 폴더입니다(ex : static). mediaRoot : tina로 관리할 media폴더입니다. publicFolder/mediaRoot 경로로 저장됩니다. #\rGitHub Action\r저는 GitHub Pages를 이용해 호스팅을 했습니다. 만약 Vercel이나 Netlify를 이용한다면 각각 페이지를 참고해주세요.\n.github/workflows/static.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 # Simple workflow for deploying static content to GitHub Pages name: Deploy static content to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false jobs: # Single deploy job since we\u0026#39;re just deploying deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true - name: Setup Node uses: actions/setup-node@v4 with: node-version: \u0026#34;16\u0026#34; - name: Cache node modules for TinaCMS id: cache-npm uses: actions/cache@v3 env: cache-name: cache-node-modules with: # npm cache files are stored in `~/.npm` on Linux/macOS path: ~/.npm key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles(\u0026#39;**/package-lock.json\u0026#39;) }} restore-keys: | ${{ runner.os }}-build-${{ env.cache-name }}- ${{ runner.os }}-build- ${{ runner.os }}- - if: ${{ steps.cache-npm.outputs.cache-hit != \u0026#39;true\u0026#39; }} name: List the state of node modules continue-on-error: true run: npm list - name: Install dependencies run: npm install - name: Build TinaCMS env: TINA_PUBLIC_CLIENT_ID: ${{ secrets.TINA_PUBLIC_CLIENT_ID }} TINA_TOKEN: ${{ secrets.TINA_TOKEN }} run: npx tinacms build - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.123.8\u0026#34; extended: true - name: hugo build run: | hugo - name: Setup Pages uses: actions/configure-pages@v4 - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: # Upload entire repository path: \u0026#34;./public\u0026#34; - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 name을 따라가시면 쉽게 파악하실겁니다. 언제 실행할 지 등 기호에 맞게 수정해주세요!\nBuild TinaCMS -\u0026gt; Setup Hugo 순서는 맞춰주시는 게 좋습니다.\n#\r환경 세팅\r깃허브 레파지토리의 Settings -\u0026gt; Environments -\u0026gt; github-pages에 환경변수를 추가해주세요.\nEnvironment secrets에 TINA_PUBLIC_CLIENT_ID과 TINA_TOKEN를 넣어주시면 됩니다.\n이후, main 브랜치에 push될 때마다 자동으로 블로그가 build됩니다.\n#\r오류 관련\r환경 세팅 및 변수명이 제대로 되어 있는 지 확인해 주세요. branch설정 확인 : master branch 안될 수 있습니다. submodule 확인 : 이부분에서 좀 헤맸었는데 theme을 submodule로 관리하신다면 GitHub Action 중 Checkout step에서 submodules: true 설정을 해주셔야 hugo build 부분이 제대로 빌드가 됩니다. hugo build 확인 : config.toml에 따라 hugo -t stack 등 명령어가 상이할 수 있습니다. #\r결과 확인\r호스팅 되는 주소/admin 으로 접속하시면 Tina에 로그인할 수 있습니다.\n로그인 후 게시글 생성/수정/삭제를 했을 때 github에 commit이 올라가며 페이지가 빌드되시는 것을 확인할 수 있습니다.\nTina Cloud 페이지에서 Setup Checklist로 제대로 연결이 되었는지도 확인하실 수 있습니다.\n#\r후기\rTinaCMS으로 게시글 작성이 많이 편해졌으나 다음과 같은 사항들은 존재합니다.\n임시저장 없음\n게시글을 저장하거나, Media를 올릴 때 마다 commit이 올라가기에 저는 글을 다 작성 후 저장하고 있었습니다. 하지만 이 때문에 글을 통째로 날려버리게 된 후 그냥 신경안쓰고 commit을 날리고 있습니다.\n또한 글을 작성하다 왼쪽 메뉴를 클릭하게 되신다면 소리없이 사라져버리는 글을 볼 수 있습니다 주륵. . . 데이터 관련 오류\nMarkdown이 가끔 제대로 먹지 않거나, 파일을 찾을 수 없는 문제가 종종 발생합니다. Media 관리\n미디어 업로드 시 이름 변경이 안됩니다. 미리 이름을 설정하시고 업로드 하셔야 해요. Stack 테마와 완벽히 호환안됨\n이것은 어찌보면 당연하지만 기존 구성에 대해 미디어와 관련해 안맞는 부분이 있습니다.\nstatic에서 가져오는 미디어는 caption이 보이지 않으며, 중앙 정렬이 안됩니다. 그럼에도 VSCode등 별도의 IDE나 세팅없이 새로운 글을 작성하고, 바로 Deploy할 수 있는 것은 너무 매력적입니다.\n이 글을 보시는 분들도 한번 적용해보시기 바랍니다.\n","date":"2024-03-16T06:34:30.453Z","image":"http://localhost:1313/article/tinacms-static-site-online-edit/tinacms.png","permalink":"http://localhost:1313/article/tinacms-static-site-online-edit/","title":"TinaCMS로 정적 사이트 온라인 편집하기 with Hugo"},{"content":"\r#\rWhat You Will Build\rStringRedisTemplate를 이용하여 메세지를 게시하고, MessageListenerAdapter를 이용하여 메세지를 가져오는 POJO를 구현해봅시다.\n#\rStanding up a Redis server\r메세지의 수신과 송신을 컨트롤하기 위한 서버가 필요하기 때문에, Redis를 설치해서 서버를 띄워야 합니다.\nRedis는 key-value의 데이터 저장소이며, 메세징 시스템을 제공합니다. 참고로 Redis는 캐싱에도 이용되는데 여기에 간단하게 정리해뒀습니다!\nRedis 설치는 https://redis.io/download에서 가능합니다. 별도의 설정이 없다면 6379포트로 접근하면 이용할 수 있습니다.\nSpring프로젝트를 시작할 때 Dependencies에서 Spring Data Redis를 체크하시거나 그냥 넘어가셨다면 직접 추가해주세요.\n1 implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-redis\u0026#39; #\rCreate a Redis Message Receiver\rsrc/main/java/com/example/messagingredis/Receiver.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.messagingredis; import java.util.concurrent.atomic.AtomicInteger; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Receiver { private static final Logger LOGGER = LoggerFactory.getLogger(Receiver.class); private AtomicInteger counter = new AtomicInteger(); public void receiveMessage(String message) { LOGGER.info(\u0026#34;Received \u0026lt;\u0026#34; + message + \u0026#34;\u0026gt;\u0026#34;); counter.incrementAndGet(); } public int getCount() { return counter.get(); } } Receiver는 메세지를 수신하는 방법을 정의하는 POJO입니다. 메세지 리스너로 등록하면 메서드 이름을 원하는 대로 지정할 수 있습니다.\n예제에서는 메세지를 수신할 때마다 메세지를 세는 방식으로 동작하여 메세지를 수신했다고 알릴 수 있습니다.\n#\rRegister the Listener and Send a Message\rSpring Data Redis에서는 수신/송신에 필요한 컴포넌트들을 제공하며, 다음을 설정해야 합니다.\nA connection factory : message listener container와 Redis template을 Redis 서버에 연결 A message listener container : Receiver등록(메세지 수신) A Redis template : 메세지 송신 src/main/java/com/example/messagingredis/MessagingRedisApplication.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package com.example.messagingredis; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.listener.PatternTopic; import org.springframework.data.redis.listener.RedisMessageListenerContainer; import org.springframework.data.redis.listener.adapter.MessageListenerAdapter; @SpringBootApplication public class MessagingRedisApplication { private static final Logger LOGGER = LoggerFactory.getLogger(MessagingRedisApplication.class); @Bean RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter) { RedisMessageListenerContainer container = new RedisMessageListenerContainer(); container.setConnectionFactory(connectionFactory); container.addMessageListener(listenerAdapter, new PatternTopic(\u0026#34;chat\u0026#34;)); return container; } @Bean MessageListenerAdapter listenerAdapter(Receiver receiver) { return new MessageListenerAdapter(receiver, \u0026#34;receiveMessage\u0026#34;); } @Bean Receiver receiver() { return new Receiver(); } @Bean StringRedisTemplate template(RedisConnectionFactory connectionFactory) { return new StringRedisTemplate(connectionFactory); } public static void main(String[] args) throws InterruptedException { ApplicationContext ctx = SpringApplication.run(MessagingRedisApplication.class, args); StringRedisTemplate template = ctx.getBean(StringRedisTemplate.class); Receiver receiver = ctx.getBean(Receiver.class); while (receiver.getCount() == 0) { LOGGER.info(\u0026#34;Sending message...\u0026#34;); template.convertAndSend(\u0026#34;chat\u0026#34;, \u0026#34;Hello from Redis!\u0026#34;); Thread.sleep(500L); } System.exit(0); } } #\r결과\r정상적으로 송/수신 되는 것을 확인할 수 있습니다.\n","date":"2024-03-15T12:08:56Z","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/messaging-with-redis/","title":"Messaging with Redis"},{"content":"\r#\rWhat You Will Build\rSpring Security에 내장되어 있는 LDAP 서버를 통해 웹 어플리케이션 보안을 구축해보자.\nLDAP 서버는 유저들을 포함한 data file로 로드한다.\n#\rLDAP\r네트워크상에서 조직이나 개인, 파일, 디바이스 등을 찾아볼 수 있게 해주는 소프트웨어 프로토콜입니다. LDAP이 등장하기 전 디렉토리 서비스 표준인 X.500의 DAP(Directory Access Protocol)가 존재했지만 OSI 계층 전체의 프로토콜을 지원하고 통신 간에 네트워크 자원을 많이 소비하는 등 운영 환경에 제약이 많았습니다. LDAP은 OSI 계층 전체가 아닌 TCP/IP 위에서 운용되고 DAP의 스펙을 최대한 유지하면서도 경량화해 네트워크 부담을 줄이도록 설계되었습니다.\nLDAP을 이용한 디렉토리 서버도 데이터를 저장하는 데이터베이스의 유형 중 하나입니다. 트리 구조로 이루어져 있기에 검색 및 읽기 작업에서 관계형 데이터베이스보다 유리합니다.\n#\rCreate a Simple Web Controller\rsrc/main/java/com/example/authenticatingldap/HomeController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.authenticatingldap; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HomeController { @GetMapping(\u0026#34;/\u0026#34;) public String index() { return \u0026#34;Welcome to the home page!\u0026#34;; } } GET 요청시 간단한 메세지를 전송하는 어플리케이션이나, 보안에 대한 설정이 되어 있지 않다.\n#\rSet up Spring Security\rbuild.grale\n1 2 3 4 implementation(\u0026#34;org.springframework.boot:spring-boot-starter-security\u0026#34;) implementation(\u0026#34;org.springframework.ldap:spring-ldap-core\u0026#34;) implementation(\u0026#34;org.springframework.security:spring-security-ldap\u0026#34;) implementation(\u0026#34;com.unboundid:unboundid-ldapsdk\u0026#34;) dependencies에 추가하자.\nsrc/main/java/com/example/authenticatingldap/WebSecurityConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.example.authenticatingldap; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.Customizer; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.context.annotation.Bean; import org.springframework.beans.factory.annotation.Autowired; @Configuration public class WebSecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -\u0026gt; authorize .anyRequest().fullyAuthenticated() ) .formLogin(Customizer.withDefaults()); return http.build(); } @Autowired public void configure(AuthenticationManagerBuilder auth) throws Exception { auth .ldapAuthentication() .userDnPatterns(\u0026#34;uid={0},ou=people\u0026#34;) .groupSearchBase(\u0026#34;ou=groups\u0026#34;) .contextSource() .url(\u0026#34;ldap://localhost:8389/dc=springframework,dc=org\u0026#34;) .and() .passwordCompare() .passwordEncoder(new BCryptPasswordEncoder()) .passwordAttribute(\u0026#34;userPassword\u0026#34;); } } SecurityFilterChain() : url에 대한 인가 설정\nconfigure() : 인증 메서드\n#\rAdd Application Properties\rapplication.properties\n1 2 3 spring.ldap.embedded.ldif=classpath:test-server.ldif spring.ldap.embedded.base-dn=dc=springframework,dc=org spring.ldap.embedded.port=8389 configure메서드의 contextSource에 대한 설정을 맞춰준다.\n#\rSet up User Data\rsrc/main/resources/test-server.ldif\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 dn: dc=springframework,dc=org objectclass: top objectclass: domain objectclass: extensibleObject dc: springframework dn: ou=groups,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: groups dn: ou=subgroups,ou=groups,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: subgroups dn: ou=people,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: people dn: ou=space cadets,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: space cadets dn: ou=\\\u0026#34;quoted people\\\u0026#34;,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: \u0026#34;quoted people\u0026#34; dn: ou=otherpeople,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: otherpeople dn: uid=ben,ou=people,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Ben Alex sn: Alex uid: ben userPassword: $2a$10$c6bSeWPhg06xB1lvmaWNNe4NROmZiSpYhlocU/98HNr2MhIOiSt36 dn: uid=bob,ou=people,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Bob Hamilton sn: Hamilton uid: bob userPassword: bobspassword dn: uid=joe,ou=otherpeople,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Joe Smeth sn: Smeth uid: joe userPassword: joespassword dn: cn=mouse\\, jerry,ou=people,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Mouse, Jerry sn: Mouse uid: jerry userPassword: jerryspassword dn: cn=slash/guy,ou=people,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: slash/guy sn: Slash uid: slashguy userPassword: slashguyspassword dn: cn=quote\\\u0026#34;guy,ou=\\\u0026#34;quoted people\\\u0026#34;,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: quote\\\u0026#34;guy sn: Quote uid: quoteguy userPassword: quoteguyspassword dn: uid=space cadet,ou=space cadets,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Space Cadet sn: Cadet uid: space cadet userPassword: spacecadetspassword dn: cn=developers,ou=groups,dc=springframework,dc=org objectclass: top objectclass: groupOfUniqueNames cn: developers ou: developer uniqueMember: uid=ben,ou=people,dc=springframework,dc=org uniqueMember: uid=bob,ou=people,dc=springframework,dc=org dn: cn=managers,ou=groups,dc=springframework,dc=org objectclass: top objectclass: groupOfUniqueNames cn: managers ou: manager uniqueMember: uid=ben,ou=people,dc=springframework,dc=org uniqueMember: cn=mouse\\, jerry,ou=people,dc=springframework,dc=org dn: cn=submanagers,ou=subgroups,ou=groups,dc=springframework,dc=org objectclass: top objectclass: groupOfUniqueNames cn: submanagers ou: submanager uniqueMember: uid=ben,ou=people,dc=springframework,dc=org LDIF 파일을 사용하는 것은 프로덕션 시스템에서는 보편적인 방법이 아니다.\n#\r결과\rusername = ben\npassword = benspassword\n입력 시\n잘 로그인 되는 것을 확인할 수 있다.\nSpring Security 프레임워크는 spring.io 가이드를 전부 리뷰한 뒤 자세하게 다뤄보도록 하겠습니다.\n","date":"2024-03-14T18:44:35+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/authenticating-a-user-with-ldap/","title":"Authenticating a User with LDAP"},{"content":"\r#\rWhat You Will Build\r파일 업로드를 받아보고, 업로드 테스트를 위한 간단한 HTML 화면을 만들어보자.\n#\rCreate a File Upload Controller\r컨트롤러를 작성하기 앞서, Controller 에서 사용할 Service의 인터페이스를 먼저 작성하자.\n이 편이 Controller를 작성할 때 메서드를 쉽게 연결할 수 있어 편하다.\nsrc/main/java/com/example/uploadingfiles/storage/StorageService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.example.uploadingfiles.storage; import org.springframework.core.io.Resource; import org.springframework.web.multipart.MultipartFile; import java.nio.file.Path; import java.util.stream.Stream; public interface StorageService { void init(); void store(MultipartFile file); Stream\u0026lt;Path\u0026gt; loadAll(); Path load(String filename); Resource loadAsResource(String filename); void deleteAll(); } src/main/java/com/example/uploadingfiles/FileUploadController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package com.example.hellospring; import java.io.IOException; import java.util.stream.Collectors; import org.springframework.core.io.Resource; import org.springframework.http.HttpHeaders; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import com.example.hellospring.storage.StorageFileNotFoundException; import com.example.hellospring.storage.StorageService; @Controller public class FileUploadController { private final StorageService storageService; public FileUploadController(StorageService storageService) { this.storageService = storageService; } @GetMapping(\u0026#34;/\u0026#34;) public String listUploadedFiles(Model model) throws IOException { model.addAttribute(\u0026#34;files\u0026#34;, storageService.loadAll().map( path -\u0026gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, \u0026#34;serveFile\u0026#34;, path.getFileName().toString()).build().toUri().toString()) .collect(Collectors.toList())); return \u0026#34;uploadForm\u0026#34;; } @GetMapping(\u0026#34;/files/{filename:.+}\u0026#34;) @ResponseBody public ResponseEntity\u0026lt;Resource\u0026gt; serveFile(@PathVariable String filename) { Resource file = storageService.loadAsResource(filename); if (file == null) return ResponseEntity.notFound().build(); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + file.getFilename() + \u0026#34;\\\u0026#34;\u0026#34;).body(file); } @PostMapping(\u0026#34;/\u0026#34;) public String handleFileUpload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file, RedirectAttributes redirectAttributes) { storageService.store(file); redirectAttributes.addFlashAttribute(\u0026#34;message\u0026#34;, \u0026#34;You successfully uploaded \u0026#34; + file.getOriginalFilename() + \u0026#34;!\u0026#34;); return \u0026#34;redirect:/\u0026#34;; } @ExceptionHandler(StorageFileNotFoundException.class) public ResponseEntity\u0026lt;?\u0026gt; handleStorageFileNotFound(StorageFileNotFoundException exc) { return ResponseEntity.notFound().build(); } } listUploadedFiles(Model model) : 업로드를 위한 HTML 페이지를 보여주고, 업로드한 파일의 리스트를 가져온다.\nserveFile(@PathVariable String filename) : listUploadedFiles()에서 파일을 가져오기 위해 사용하는 메서드\nhandleStorageFileNotFound(StorageFileNotFoundException exc) : Exception에 대한 핸들러이다. 핸들러 메서드는 없어도 서비스는 작동하지만 추후 작성할 테스트 코드에서 오류가 발생하며, 명시해두는 편이 좋다.\nsrc/main/java/com/example/uploadingfiles/storage/\n경로 안에 storage service를 위한 클래스들을 작성한다.\nStorageProperties.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.uploadingfiles.storage; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(\u0026#34;storage\u0026#34;) public class StorageProperties { /** * Folder location for storing files */ private String location = \u0026#34;upload-dir\u0026#34;; public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } } StorageException.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.example.uploadingfiles.storage; public class StorageException extends RuntimeException { public StorageException(String message) { super(message); } public StorageException(String message, Throwable cause) { super(message, cause); } } StorageFileNotFoundException.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.example.uploadingfiles.storage; public class StorageFileNotFoundException extends StorageException { public StorageFileNotFoundException(String message) { super(message); } public StorageFileNotFoundException(String message, Throwable cause) { super(message, cause); } } FileSystemStorageService.java\nStorageService의 구현체이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 package com.example.uploadingfiles.storage; import java.io.IOException; import java.io.InputStream; import java.net.MalformedURLException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardCopyOption; import java.util.stream.Stream; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.Resource; import org.springframework.core.io.UrlResource; import org.springframework.stereotype.Service; import org.springframework.util.FileSystemUtils; import org.springframework.util.StringUtils; import org.springframework.web.multipart.MultipartFile; @Service public class FileSystemStorageService implements StorageService { private final Path rootLocation; @Autowired public FileSystemStorageService(StorageProperties properties) { if(properties.getLocation().trim().length() == 0){ throw new StorageException(\u0026#34;File upload location can not be Empty.\u0026#34;); } this.rootLocation = Paths.get(properties.getLocation()); } @Override public void store(MultipartFile file) { try { if (file.isEmpty()) { throw new StorageException(\u0026#34;Failed to store empty file.\u0026#34;); } Path destinationFile = this.rootLocation.resolve( Paths.get(file.getOriginalFilename())) .normalize().toAbsolutePath(); if (!destinationFile.getParent().equals(this.rootLocation.toAbsolutePath())) { throw new StorageException( \u0026#34;Cannot store file outside current directory.\u0026#34;); } try (InputStream inputStream = file.getInputStream()) { Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING); } } catch (IOException e) { throw new StorageException(\u0026#34;Failed to store file.\u0026#34;, e); } } @Override public Stream\u0026lt;Path\u0026gt; loadAll() { try { return Files.walk(this.rootLocation, 1) .filter(path -\u0026gt; !path.equals(this.rootLocation)) .map(this.rootLocation::relativize); } catch (IOException e) { throw new StorageException(\u0026#34;Failed to read stored files\u0026#34;, e); } } @Override public Path load(String filename) { return rootLocation.resolve(filename); } @Override public Resource loadAsResource(String filename) { try { Path file = load(filename); Resource resource = new UrlResource(file.toUri()); if (resource.exists() || resource.isReadable()) { return resource; } else { throw new StorageFileNotFoundException( \u0026#34;Could not read file: \u0026#34; + filename); } } catch (MalformedURLException e) { throw new StorageFileNotFoundException(\u0026#34;Could not read file: \u0026#34; + filename, e); } } @Override public void deleteAll() { FileSystemUtils.deleteRecursively(rootLocation.toFile()); } @Override public void init() { try { Files.createDirectories(rootLocation); } catch (IOException e) { throw new StorageException(\u0026#34;Could not initialize storage\u0026#34;, e); } } } #\rCreating an HTML Template\rsrc/main/resources/templates/uploadForm.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;html xmlns:th=\u0026#34;https://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div th:if=\u0026#34;${message}\u0026#34;\u0026gt; \u0026lt;h2 th:text=\u0026#34;${message}\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;form method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;File to upload:\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Upload\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;file : ${files}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;${file}\u0026#34; th:text=\u0026#34;${file}\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; #\rTuning File Upload Limits\rsrc/main/resources/application.properties\n1 2 spring.servlet.multipart.max-file-size=128KB spring.servlet.multipart.max-request-size=128KB #\rUpdate the Application\rsrc/main/java/com/example/uploadingfiles/UploadingFilesApplication.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.uploadingfiles; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import com.example.uploadingfiles.storage.StorageProperties; import com.example.uploadingfiles.storage.StorageService; @SpringBootApplication @EnableConfigurationProperties(StorageProperties.class) public class UploadingFilesApplication { public static void main(String[] args) { SpringApplication.run(UploadingFilesApplication.class, args); } @Bean CommandLineRunner init(StorageService storageService) { return (args) -\u0026gt; { storageService.deleteAll(); storageService.init(); }; } } #\r결과\r나는 이미지도 미리보기 위해 HTML파일을 살짝 수정했다.\n파일이 정상적으로 저장되는 것을 볼 수 있다.\n#\rTesting Your Application\rMockMvc1를 이용하여 servlet container2를 실행하지 않고 테스트를 수행할 수 있다.\nsrc/test/java/com/example/uploadingfiles/FileUploadTests.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package com.example.uploadingfiles; import java.nio.file.Paths; import java.util.stream.Stream; import org.hamcrest.Matchers; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.mock.web.MockMultipartFile; import org.springframework.test.web.servlet.MockMvc; import static org.mockito.BDDMockito.given; import static org.mockito.BDDMockito.then; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.multipart; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.header; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; import com.example.uploadingfiles.storage.StorageFileNotFoundException; import com.example.uploadingfiles.storage.StorageService; @AutoConfigureMockMvc @SpringBootTest public class FileUploadTests { @Autowired private MockMvc mvc; @MockBean private StorageService storageService; @Test public void shouldListAllFiles() throws Exception { given(this.storageService.loadAll()) .willReturn(Stream.of(Paths.get(\u0026#34;first.txt\u0026#34;), Paths.get(\u0026#34;second.txt\u0026#34;))); this.mvc.perform(get(\u0026#34;/\u0026#34;)).andExpect(status().isOk()) .andExpect(model().attribute(\u0026#34;files\u0026#34;, Matchers.contains(\u0026#34;http://localhost/files/first.txt\u0026#34;, \u0026#34;http://localhost/files/second.txt\u0026#34;))); } @Test public void shouldSaveUploadedFile() throws Exception { MockMultipartFile multipartFile = new MockMultipartFile(\u0026#34;file\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;text/plain\u0026#34;, \u0026#34;Spring Framework\u0026#34;.getBytes()); this.mvc.perform(multipart(\u0026#34;/\u0026#34;).file(multipartFile)) .andExpect(status().isFound()) .andExpect(header().string(\u0026#34;Location\u0026#34;, \u0026#34;/\u0026#34;)); then(this.storageService).should().store(multipartFile); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Test public void should404WhenMissingFile() throws Exception { given(this.storageService.loadAsResource(\u0026#34;test.txt\u0026#34;)) .willThrow(StorageFileNotFoundException.class); this.mvc.perform(get(\u0026#34;/files/test.txt\u0026#34;)).andExpect(status().isNotFound()); } } #\r결과\r테스트 시 Spring을 시작하지 않기 때문에 빠르게 테스트할 수 있다.\nHTTP 요청 및 응답을 모의(mock)로 처리하여 서버를 실행하지 않고도 컨트롤러 및 REST 엔드포인트를 테스트할 수 있게 해준다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n서블릿의 라이프사이클을 관리하고 HTTP 요청을 받아들이며, 서블릿 코드의 실행을 처리하고 그 결과를 클라이언트에게 반환. Apache Tomcat, Jetty, IBM WebSphere 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-03-14T16:23:56+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/uploading-files/","title":"Uploading Files"},{"content":"\r#\rWhat You Will Build\rJdbcTemplate를 사용하여 관계형 데이터베이스에 접근하기\n#\rInitial\r프로젝트를 생성하며 JDBC API와 H2 Database의 Dependencies를 추가하거나, build.grade에서 직접 추가한다.\n1 2 3 4 5 6 7 8 dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; compileOnly \u0026#39;org.projectlombok:lombok\u0026#39; annotationProcessor \u0026#39;org.projectlombok:lombok\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-jdbc\u0026#39; //new runtimeOnly \u0026#39;com.h2database:h2\u0026#39; //new } #\rCreate a Customer Object\rsrc/main/java/com/example/relationaldataaccess/Customer.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.relationaldataaccess; public class Customer { private long id; private String firstName, lastName; public Customer(long id, String firstName, String lastName) { this.id = id; this.firstName = firstName; this.lastName = lastName; } @Override public String toString() { return String.format( \u0026#34;Customer[id=%d, firstName=\u0026#39;%s\u0026#39;, lastName=\u0026#39;%s\u0026#39;]\u0026#34;, id, firstName, lastName); } // getters \u0026amp; setters는 간략화를 위해 생략 } #\rStore and Retrieve Data\rSpring은 SQL 관계형 데이터베이스와 JDBC를 사용하기 쉽게 해주는 JdbcTemplate이라는 템플릿 클래스를 제공한다.\nJdbcTemplate는 리소스 획득, 연결 관리, 예외 처리 및 코드의 목적과는 전혀 관련이 없는 일반적인 오류 확인 등을 대신 처리해준다.\nsrc/main/java/com/example/relationaldataaccess/RelationalDataAccessApplication.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.relationaldataaccess; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.jdbc.core.JdbcTemplate; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; @SpringBootApplication public class RelationalDataAccessApplication implements CommandLineRunner { private static final Logger log = LoggerFactory.getLogger(RelationalDataAccessApplication.class); public static void main(String args[]) { SpringApplication.run(RelationalDataAccessApplication.class, args); } @Autowired JdbcTemplate jdbcTemplate; @Override public void run(String... strings) throws Exception { log.info(\u0026#34;Creating tables\u0026#34;); jdbcTemplate.execute(\u0026#34;DROP TABLE customers IF EXISTS\u0026#34;); jdbcTemplate.execute(\u0026#34;CREATE TABLE customers(\u0026#34; + \u0026#34;id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))\u0026#34;); List\u0026lt;Object[]\u0026gt; splitUpNames = Arrays.asList(\u0026#34;John Woo\u0026#34;, \u0026#34;Jeff Dean\u0026#34;, \u0026#34;Josh Bloch\u0026#34;, \u0026#34;Josh Long\u0026#34;).stream() .map(name -\u0026gt; name.split(\u0026#34; \u0026#34;)) .collect(Collectors.toList()); splitUpNames.forEach(name -\u0026gt; log.info(String.format(\u0026#34;Inserting customer record for %s %s\u0026#34;, name[0], name[1]))); jdbcTemplate.batchUpdate(\u0026#34;INSERT INTO customers(first_name, last_name) VALUES (?,?)\u0026#34;, splitUpNames); log.info(\u0026#34;Querying for customer records where first_name = \u0026#39;Josh\u0026#39;:\u0026#34;); jdbcTemplate.query( \u0026#34;SELECT id, first_name, last_name FROM customers WHERE first_name = ?\u0026#34;, (rs, rowNum) -\u0026gt; new Customer(rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;first_name\u0026#34;), rs.getString(\u0026#34;last_name\u0026#34;)), \u0026#34;Josh\u0026#34;) .forEach(customer -\u0026gt; log.info(customer.toString())); } } Spring Boot는 H2(인메모리 관계형 데이터베이스 엔진)를 지원하며 자동으로 연결을 생성한다.\n현재는 spring-jdbc를 사용하기 때문에, Spring Boot는 자동으로 JdbcTemplate을 생성한다.\nString... strings는 임의의 개수의 문자열을 매개변수로 받음을 의미 여러 insert문을 이용한다면 batchUpdate사용, 단일이라면 insert arguments에 ?를 이용하여 SQL injection 공격을 피할 수 있음 #\r결과\r","date":"2024-03-12T23:29:18+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/accessing-relational-data-using-jdbc-with-spring/","title":"Accessing Relational Data using JDBC with Spring"},{"content":"\r#\rWhat You Will Build\rRestTemplate를 사용하여 API 요청을 통해 랜덤 스프링 인용구를 검색해보자.\n#\rFetching a REST Resource\rhttps://github.com/spring-guides/quoters를 실행시킨다.\n브라우저나 curl에서 http://localhost:8080/api/로 요청을 보내면 JSON 문서를 받을 수 있으나, 그렇게 유용하지는 않다.\nSpring은 API에 접근하기 위해 RestTemplate를 제공한다.\nRestTemplate를 이용하기 위해 Spring Application을 작성해보자.\n#\rdomain class\r필요한 데이터를 담기 위한 domain class 만들기\nsrc/main/java/com/example/consumingrest/Quote.java\n1 2 3 4 5 6 package com.example.consumingrest; import com.fasterxml.jackson.annotation.JsonIgnoreProperties; @JsonIgnoreProperties(ignoreUnknown = true) public record Quote(String type, Value value) { } @JsonIgnoreProperties 어노테이션을 통해 type과 맞지 않는 데이터를 무시할 수 있다.\n만약 name과 Json의 키값이 일치하지 않는다면, @JsonProperty를 통해 설정할 수 있다.\n1 2 public record Quote(@JsonProperty(\u0026#34;ty\u0026#34;) String type, Value value) { } 다음과 같이 작성한다면 ty와 일치하는 JSON 키값이 없기 때문에 type에 null이 나오게 된다.\nsrc/main/java/com/example/consumingrest/Value.java\n1 2 3 4 5 6 package com.example.consumingrest; import com.fasterxml.jackson.annotation.JsonIgnoreProperties; @JsonIgnoreProperties(ignoreUnknown = true) public record Value(Long id, String quote) { } Value를 정의하기 위한 recod 클래스이다.\n#\rApplication.java\rRESTful source를 보기위해 Application class에 다음을 세팅한다.\noutput을 보내기 위한 logger data 프로세싱을 위한 RestTemplate 시작 시 RestTemplate와 데이터를 받아오기 위한 CommandLineRunner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.example.consumingrest; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Profile; import org.springframework.web.client.RestTemplate; @SpringBootApplication public class ConsumingRestApplication { private static final Logger log = LoggerFactory.getLogger(ConsumingRestApplication.class); public static void main(String[] args) { SpringApplication.run(ConsumingRestApplication.class, args); } @Bean public RestTemplate restTemplate(RestTemplateBuilder builder) { return builder.build(); } @Bean @Profile(\u0026#34;!test\u0026#34;) public CommandLineRunner run(RestTemplate restTemplate) throws Exception { return args -\u0026gt; { Quote quote = restTemplate.getForObject( \u0026#34;http://localhost:8080/api/random\u0026#34;, Quote.class); log.info(quote.toString()); }; } } 마지막으로, application.properties에서 서버 포트를 설정하고 실행시킨다.\n1 server.port=8081 #\r결과\rTerminal에 데이터가 제대로 수신되는 것을 확인할 수 있다.\n","date":"2024-03-12T22:43:56+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/consuming-a-restful-web-service/","title":"Consuming a RESTful Web Service"},{"content":"\r#\rWhat You Will Build\rSpring의 @Scheduled 어노테이션을 이용하여 5초에 한번씩 현재 시간을 출력하는 어플리케이션을 만들어보자.\n#\rAdding awaitility Dependency\rTask Scheduling을 위해서 awaitility 라이브러리를 추가해야 한다.\nbuild.gradle\n1 2 3 4 5 dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter\u0026#39; testImplementation \u0026#39;org.awaitility:awaitility:4.2.0\u0026#39; testImplementation(\u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;) } #\rCreate a Scheduled Task\rsrc/main/java/com/example/schedulingtasks/ScheduledTasks.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.example.schedulingtasks; import java.text.SimpleDateFormat; import java.util.Date; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @Component public class ScheduledTasks { private static final Logger log = LoggerFactory.getLogger(ScheduledTasks.class); private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\u0026#34;HH:mm:ss\u0026#34;); @Scheduled(fixedRate = 5000) public void reportCurrentTime() { log.info(\u0026#34;The time is now {}\u0026#34;, dateFormat.format(new Date())); } } 예제에서는 fixedRate를 이용했지만, fixedDelay나 cron을 사용하여 스케줄링을 할 수도 있다.\ncron의 경우 \u0026quot;0 * * * * MON-FRI\u0026quot;로 설정하면 월-금동안 1분에 한번씩 실행된다.\n#\rEnable Scheduling\rsrc/main/java/com/example/schedulingtasks/SchedulingTasksApplication.java\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026#39;\u0026#39;\u0026#39; 생략 \u0026#39;\u0026#39;\u0026#39; @SpringBootApplication @EnableScheduling public class SchedulingTasksApplication { public static void main(String[] args) { SpringApplication.run(SchedulingTasksApplication.class); } } @EnableScheduling 어노테이션을 통해 background task executor가 생성되었다는 것을 명시한다.\n#\r결과\r","date":"2024-03-12T16:00:14+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/scheduling-tasks/","title":"Scheduling Tasks"},{"content":"\r#\rWhat You Will Build\rhttp://localhost:8080/greeting으로 HTTP GET요청이 들어오면 JSON 데이터를 보내주는 것이 목표이다.\nhttp://localhost:8080/greeting?name=User 와 같은 요청이 들어온다면\n{\u0026ldquo;id\u0026rdquo;:1,\u0026ldquo;content\u0026rdquo;:\u0026ldquo;Hello, User!\u0026rdquo;} 의 JSON데이터를 보내줘야 한다.\n#\rCreate a Resource Representation Class\rsrc/main/java/com/example/restservice/Greeting.java\n1 2 3 package com.example.restservice; public record Greeting(long id, String content) { } record키워드는 이 곳에 정리해두었다.\n#\rCreate a Resource Controller\rsrc/main/java/com/example/restservice/GreetingController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.restservice; import java.util.concurrent.atomic.AtomicLong; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class GreetingController { private static final String template = \u0026#34;Hello, %s!\u0026#34;; private final AtomicLong counter = new AtomicLong(); @GetMapping(\u0026#34;/greeting\u0026#34;) public Greeting greeting(@RequestParam(value = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;World\u0026#34;) String name) { return new Greeting(counter.incrementAndGet(), String.format(template, name)); } } 예제의 경우 template가 static final로 선언되어 있다. 하지만 Controller는 단일 인스턴스로 bean 컨테이너에 등록되어 공유하기 때문에 static이 필요한지 의문이다.\n#\r결과\r요청할 때마다 id값이 증가하며 JSON데이터가 오는 것을 확인할 수 있다.\n","date":"2024-03-12T00:00:01+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/building-a-restful-web-service/","title":"Building a RESTful Web Service"},{"content":"\r#\rrecord\rJDK 14에서 추가된 키워드로, 타입과 필드 이름만 필요로 하는 불변 데이터 클래스이다.\n1 public record Person (String name, String address) {} #\r기본 기능\rConstructor\n1 2 3 4 public Person(String name, String address) { this.name = name; this.address = address; } Getters\n1 2 3 4 5 6 7 8 9 10 @Test public void givenValidNameAndAddress_whenGetNameAndAddress_thenExpectedValuesReturned() { String name = \u0026#34;John Doe\u0026#34;; String address = \u0026#34;100 Linda Ln.\u0026#34;; Person person = new Person(name, address); assertEquals(name, person.name()); assertEquals(address, person.address()); } equals\n1 2 3 4 5 6 7 8 9 10 @Test public void givenSameNameAndAddress_whenEquals_thenPersonsEqual() { String name = \u0026#34;John Doe\u0026#34;; String address = \u0026#34;100 Linda Ln.\u0026#34;; Person person1 = new Person(name, address); Person person2 = new Person(name, address); assertTrue(person1.equals(person2)); } hashCode\n필드값이 모두 일치한다면, 같은 해시코드를 반환한다.(birthday paradox로 인한 충돌을 방지하기 위함)\n1 2 3 4 5 6 7 8 9 10 @Test public void givenSameNameAndAddress_whenHashCode_thenPersonsEqual() { String name = \u0026#34;John Doe\u0026#34;; String address = \u0026#34;100 Linda Ln.\u0026#34;; Person person1 = new Person(name, address); Person person2 = new Person(name, address); assertEquals(person1.hashCode(), person2.hashCode()); } toString\n1 Person[name=John Doe, address=100 Linda Ln.] #\rrecord vs. Lombok\r#\rSmall Immutable Objects\rrecord\n1 2 3 4 5 6 public record ColorRecord(int red, int green, int blue) { public String getHexString() { return String.format(\u0026#34;#%02X%02X%02X\u0026#34;, red, green, blue); } } Lombok\n1 2 3 4 5 6 7 8 9 10 @Value public class ColorValueObject { int red; int green; int blue; public String getHexString() { return String.format(\u0026#34;#%02X%02X%02X\u0026#34;, red, green, blue); } } Lombok도 @value 어노테이션을 통해 불변 데이터 객체 생성을 도와주지만, java 14 이후부터는 record가 더욱 자연스러운 선택이다.\n#\rTransparent Data Carriers\rLombok\n1 2 3 4 5 6 7 8 9 10 11 @Value @Getter(AccessLevel.NONE) public class ColorValueObject { int red; int green; int blue; public String getHexString() { return String.format(\u0026#34;#%02X%02X%02X\u0026#34;, red, green, blue); } } 일반적으로 record 사용, 멤버 필드를 공개하지 않고 싶다면 Lombok 사용\n#\rClasses With Many Fields\rrecord\n1 2 3 4 5 6 7 8 9 10 11 12 13 public record StudentRecord( String firstName, String lastName, Long studentId, String email, String phoneNumber, String address, String country, int age) { } StudentRecord john = new StudentRecord( \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, null, \u0026#34;john@doe.com\u0026#34;, null, null, \u0026#34;England\u0026#34;, 20); Lombok\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Getter @Builder public class StudentBuilder { private String firstName; private String lastName; private Long studentId; private String email; private String phoneNumber; private String address; private String country; private int age; } StudentBuilder john = StudentBuilder.builder() .firstName(\u0026#34;John\u0026#34;) .lastName(\u0026#34;Doe\u0026#34;) .email(\u0026#34;john@doe.com\u0026#34;) .country(\u0026#34;England\u0026#34;) .age(20) .build(); 필드가 많아질수록 Lombok의 Builder 패턴이 직관적이다.\n#\rMutable Data\r1 2 3 4 5 6 7 8 9 10 11 12 13 @Data @AllArgsConstructor public class ColorData { private int red; private int green; private int blue; public String getHexString() { return String.format(\u0026#34;#%02X%02X%02X\u0026#34;, red, green, blue); } } setter나 default 생성자가 필요할 때 Lombok의 @Data 등의 어노테이션이나 plain Java를 이용해야함.\n#\rInheritance\r1 2 3 4 5 6 7 @Value public class MonochromeColor extends ColorData { public MonochromeColor(int grayScale) { super(grayScale, grayScale, grayScale); } } record는 상속을 지원하지 않음.\n","date":"2024-03-12T00:00:01+09:00","image":"http://localhost:1313/cover/java.png","permalink":"http://localhost:1313/article/record-keyword/","title":"record 키워드"},{"content":"\r#\rDescription\r문제 링크\nGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\n1 2 3 4 5 6 7 8 9 int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\n1 2 3 4 Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\n1 2 3 4 Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order. #\r풀이\r주어진 nums는 non-decresing order로 정렬이 되어있기 떄문에 idx =1부터 시작하여 i와 i-1이 다른 숫자라면 nums[idx]에 nums[i]를 저장하여 풀이했다.\n#\r코드\r1 2 3 4 5 6 7 8 class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: idx = 1 for i in range(1, len(nums)): if nums[i] != nums[i-1]: nums[idx] = nums[i] idx += 1 return idx ","date":"2024-03-11T21:53:43+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/leetcode-26/","title":"26. Remove Duplicates from Sorted Array"},{"content":"\r#\rDescription\r문제 링크\nGiven an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\n1 2 3 4 Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\n1 2 3 4 5 Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 #\r풀이\rval값을 제외하기 위해 nums를 순회하며 val값이 아니라면, 0번째 인덱스(idx)부터 nums[i]를 넣어 nums를 수정했다.\n만약, nums = [3, 2, 2, 3] 이고 val = 3이라면\nnums[0] == 3이고 nums[1] != 3 이기 때문에 nums[0]idx = 0 에는 nums[1]이 들어가게 된다.\n이후 nums[2] != val 이니 nums[1]idx = 1에 nums[2]가 들어간다.\n#\r코드\r1 2 3 4 5 6 7 8 class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: idx = 0 for i in range(len(nums)): if nums[i] != val: nums[idx] = nums[i] idx += 1 return idx ","date":"2024-03-11T16:43:21+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/leetcode-27/","title":"27. Remove Element"},{"content":"\r#\rDescription\r문제 링크\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\n1 2 3 4 Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\n1 2 3 4 Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\n1 2 3 4 5 Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 Follow up: Can you come up with an algorithm that runs in O(m + n) time?\n#\r풀이\rO(m + n)의 시간 복잡도를 가지기 위해, 투 포인터 개념을 활용했다.\n7번째 줄에서 while i\u0026gt;=0:으로 시도하여 풀고 있었는데 제출하자 오답이 나왔다.\n이는 m이 0일 때 i가 -1이 되어버려 while문이 아예 작동하지 않아 발생한 문제였다.\ni -\u0026gt; j로 바꾼다면 n이 0일 때 nums1 배열을 그대로 둬도 되기에(while문이 작동하지 않아도 되기에) 바꾸어 해결했다.\nExample 2, Example 3이 특수한 상황의 예시를 미리 알려주고 있어서 맞출 수 있었다고 생각한다.\nnums1배열을 pop하며 nums2의 원소를 넣은 뒤 sort()메서드를 사용하는 방법도 통과할 것 같은데, 따로 구현해보지는 않았다.\n#\r코드\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -\u0026gt; None: i = m - 1 j = n - 1 k = i + j + 1 while j\u0026gt;= 0: if i\u0026gt;= 0 and nums1[i] \u0026gt; nums2[j]: nums1[k] = nums1[i] i -= 1 else: nums1[k] = nums2[j] j -= 1 k -= 1 ","date":"2024-03-10T21:00:10+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/leetcode-88/","title":"88. Merge Sorted Array"},{"content":"\r#\r문제\r문제 링크\n인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.\n줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.\n줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.\n#\r입력\r첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)\n#\r출력\r첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.\n#\r예제\rInput :\n1 2 5 3 1 4 3 2 Output :\n32\r#\r풀이\rN과 Pi의 범위는 1000 이하로 시간복잡도가 커도 괜찮을 것이다.\nN번째 index까지의 합이 필요하기 때문에 선택 정렬을 사용하며 정렬과 인덱스의 합을 함께 계산했다.\n#\r코드\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import sys N = int(sys.stdin.readline()) S = [int(i) for i in sys.stdin.readline().split()] sum = 0 ans = 0 # using selection sort for i in range(N): min = i for j in range(i+1, N): # finding min for ith index if S[min] \u0026gt; S[j]: min = j S[min], S[i] = S[i], S[min] # switching values in indices sum += S[i] # sum waiting time ans += sum # total wating time print(ans) ","date":"2024-03-10T00:00:10+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/baekjoon-11399/","title":"11399번 : ATM"},{"content":"\r#\r의도\r부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공해 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴\n#\r문제\r물류 관리 앱을 개발하고 있다고 가정.\n앱의 첫 번째 버전은 트럭 운송만 처리할 수 있어서 대부분의 코드가 Truck​(트럭) 클래스에 존재. 해상 물류 기능을 앱에 추가해 달라는 요청 발생 앱에 Ship​(선박) 클래스를 추가하려면 전체 코드 베이스를 변경해야 함. #\r해결책\r객체 생성 직접 호출들을 팩토리 메서드에 대한 호출들로 대체.\n자식 클래스에서 팩토리 메서드를 오버라이딩하여 그 메서드에 의해 생성되는 제품들의 클래스를 변경할 수 있게 됨.\n단, 공통 기초 클래스 또는 공통 인터페이스를 두어야 함.\n#\r구조\r#\r적용 상황\r함께 작동해야 하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우\n제품 생성 코드를 제품을 실제로 사용하는 코드와 분리하기에 독립적으로 확장하기 쉬워진다.\n예를 들어, 앱에 새로운 제품을 추가하려면 새로운 크리에이터 자식 클래스를 생성한 후 해당 클래스 내부의 팩토리 메서드를 오버라이딩​(재정의)​하기만 하면 된다.\n라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트들을 확장하는 방법을 제공하고 싶을 때\n프레임워크 전체에서 컴포넌트들을 생성하는 코드를 단일 팩토리 메서드로 줄인 후, 누구나 이 팩토리 메서드를 오버라이드 할 수 있도록 만들 수 있다.\n기존 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때\n데이터베이스 연결, 파일 시스템 및 네트워크처럼 시스템 자원을 많이 사용하는 대규모 객체들을 처리할 때 자주 발생한다.\n#\r장단점\r장점\n크리에이터와 구상 제품들이 단단하게 결합되지 않도록 할 수 있다. 단일 책임 원칙. 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지관리할 수 있다. 개방/폐쇄 원칙. 당신은 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있다. 단점\n패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있다. ","date":"2024-03-09T00:00:10+09:00","image":"http://localhost:1313/cover/designpattern.png","permalink":"http://localhost:1313/article/design-patterns-factory-method/","title":"[생성 패턴] 팩토리 메서드"},{"content":"\r#\r문제\r문제 링크\nN개의 수 A1, A2, \u0026hellip;, AN과 L이 주어진다.\nDi = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. 이때, i ≤ 0 인 Ai는 무시하고 D를 구해야 한다.\n#\r입력\r첫째 줄에 N과 L이 주어진다. (1 ≤ L ≤ N ≤ 5,000,000)\n둘째 줄에는 N개의 수 Ai가 주어진다. (-109 ≤ Ai ≤ 109)\n#\r출력\r첫째 줄에 Di를 공백으로 구분하여 순서대로 출력한다.\n#\r예제\rinput :\n1 2 12 3 1 5 2 3 6 2 3 7 3 5 2 6 output :\n1 1 1 2 2 2 2 2 3 3 2 2\r#\r풀이\r데이터의 추가는 append로 가능하지만 데이터의 삭제는 양 끝에서 필요하기에 데크를 사용하여 풀이했다.\n#\r코드\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import sys from collections import deque n, l = map(int, sys.stdin.readline().split()) a = list(map(int, sys.stdin.readline().split())) deq = deque() for i in range(n): while deq and deq[-1][1] \u0026gt; a[i]: # 마지막 인덱스의 값이 i번째 인덱스 보다 크다면 pop deq.pop() deq.append((i, a[i])) if(deq[0][0] \u0026lt; i - l + 1): # 0번째 인덱스가 범위 밖으로 나가면 pop deq.popleft() print(deq[0][1], end=\u0026#39; \u0026#39;) ","date":"2024-03-09T00:00:10+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/baekjoon-11003/","title":"11003번 : 최솟값 찾기"},{"content":"\r#\r문제\rN×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.\n예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.\n여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.\n표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.\n#\r입력\r첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.\n#\r출력\r총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.\n#\r제한\r1 ≤ N ≤ 100,000 1 ≤ M ≤ 100,000 1 ≤ i ≤ j ≤ N #\r풀이\r수의 개수가 크기 때문에 부분합을 미리 구해두고 구간합을 구했다.\n#\r코드\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import sys n, cnt = map(int, sys.stdin.readline().split()) arr = [[0]*(n+1)] arrd = [[0]*(n+1) for _ in range(n+1)] # 구간 합을 구하기 위한 2차원 배열 for i in range(n): A_row = [0] + [int(x) for x in sys.stdin.readline().split()] arr.append(A_row) for i in range(1, n+1): for j in range(1, n+1): arrd[i][j] = arr[i][j] + arrd[i][j-1] + arrd[i-1][j] - arrd[i-1][j-1] #arr의 인덱스에 대한 구간 합 for i in range(cnt): x1, y1, x2, y2 = map(int, sys.stdin.readline().split()) ans = arrd[x2][y2] - arrd[x1-1][y2] - arrd[x2][y1-1] + arrd[x1-1][y1-1] # 범위의 합을 구간 합에서 계산 print(ans) ","date":"2024-03-08T00:00:10+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/baekjoon-11660/","title":"11660번 : 구간 합 구하기 5"},{"content":"\r#\r문제\r수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.\n#\r입력\r첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.\n#\r출력\r총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.\n#\r제한\r1 ≤ N ≤ 100,000 1 ≤ M ≤ 100,000 1 ≤ i ≤ j ≤ N #\r풀이\r수의 개수가 크기 때문에 구간 합을 미리 구해두고 구간합을 구했다.\n#\r코드\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sys N, M = map(int, sys.stdin.readline().split()) S = [int(i) for i in sys.stdin.readline().split()] D = [0]*N # List for subtotal D[0] = S[0] for i in range(1,N): D[i] = D[i-1] + S[i] # compute ith index\u0026#39;s subtotal for _ in range(M): start, end = map(int, sys.stdin.readline().split()) if start \u0026gt; 1: # getting value in range ans = D[end-1] - D[start-2] else : ans = D[end-1] print(ans) ","date":"2024-03-07T00:00:10+09:00","image":"http://localhost:1313/cover/algorithm.png","permalink":"http://localhost:1313/article/baekjoon-11659/","title":"11659번 : 구간 합 구하기 4"},{"content":"\r#\r디렉터리 구조\r#\rsrc/main/java 디렉터리\rsrc/main/java 디렉터리는 자바 파일을 저장하는 공간이다.\ncom.mysite.sbb 패키지 : 이 패키지는 SBB의 자바 파일을 저장하는 공간이다. HelloController.java와 같은 스프링 부트의 컨트롤러, 폼과 DTO, 데이터베이스 처리를 위한 엔티티, 서비스 등의 자바 파일이 이 곳에 위치한다.\n보통 Table 단위 등 필요 기능에 따라 패키지를 나누어 관리한다. #\rsrc/main/resources 디렉터리\rsrc/main/resources 디렉터리는 자바 파일을 제외한 HTML, CSS, 자바스크립트, 환경 파일 등을 저장하는 공간이다.\ntemplates : HTML 저장 static : css, js, 이미지 파일등 저장 application.properties : 프로젝트 설정(데이터베이스 설정 등) #\rsrc/test/java 디렉터리\rsrc/test/java 디렉터리는 프로젝트에서 작성한 파일을 테스트하는 코드를 저장하는 공간이다.\nJUnit과 스프링 부트의 테스트 도구를 사용하여 서버를 실행하지 않은 상태에서 src/main/java 디렉터리에 작성한 코드를 테스트할 수 있다.\n#\rbuild.gradle\rbuild.gradle은 그레이들(Gradle)이 사용하는 환경 파일이다. 프로젝트에 필요한 플러그인과 라이브러리를 설치하기 위한 내용을 작성한다.\n작성 후 새로고침을 해줘야 한다.\n#\rMVC 패턴\r모델(Model): 데이터를 나타내는 부분으로, 주로 데이터베이스와 연결되는 역할. 데이터의 상태를 관리하고 비즈니스 로직을 포함\n뷰(View): 사용자 인터페이스를 나타낸다. 사용자에게 데이터를 표시하고 사용자 입력을 받는 역할. HTML, XML, JSON 등과 같은 형태로 사용자에게 정보를 표시\n컨트롤러(Controller): 사용자 입력을 받고 모델을 업데이트하거나 뷰를 업데이트하는 역할. 사용자의 요청을 처리하고 그에 따른 적절한 응답을 반환\nMVC 패턴은 각 구성 요소가 서로 분리되어 있기 때문에 유지보수와 확장성이 용이하며, 코드의 재사용성을 높일 수 있다. 이는 대규모 애플리케이션 개발에서 매우 유용.\n#\r기타 구성 요소\rRepository: 데이터 액세스 계층. 데이터베이스와의 상호 작용을 담당하며, 데이터를 영구 저장소에 저장하고 검색하는데 사용. 주로 엔티티에 대한 CRUD(Create, Read, Update, Delete) 작업 수행\nService: 비즈니스 로직을 구현하는 데 사용. 비즈니스 로직은 데이터의 유효성을 검사하거나 특정 작업을 수행하는 등의 업무 규칙을 명시. Service는 주로 여러 Repository를 조합하여 트랜잭션을 관리하고, 서비스 계층을 통해 데이터 액세스 계층과 사용자 인터페이스 간의 중간 계층을 제공. 복잡한 코드를 모듈화할 수 있어서 유용\nDTO (Data Transfer Object): DTO는 데이터를 전송하는 데 사용되는 객체. 주로 서비스와 뷰 간의 데이터 전달에 사용. DTO는 주로 엔티티 클래스와 유사한 구조를 가지지만, 비즈니스 로직을 포함하지 않는다. 대신 데이터 전송을 위한 필드와 메서드만 포함. DTO는 데이터를 전송하는 과정에서 필요한 정보만 포함하여 데이터 전송의 효율성을 높임.\n이들은 MVC 패턴의 여러 계층 중에서 비즈니스 로직, 데이터 액세스, 데이터 전송 등을 담당하는 역할을 함. 이러한 구성 요소를 사용하면 코드를 더 모듈화하고 유지보수하기 쉽게 만들 수 있다.\n","date":"2024-02-22T00:00:01+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/spring-boot-project-structure/","title":"프로젝트 구조"},{"content":"\r#\r@Annotation\r코드에 부가적인 정보를 제공하는 메타데이터의 형태. 어노테이션은 @ 기호로 시작하며, 클래스, 메서드, 필드 등의 선언부에 적용될 수 있음.\n#\rSpring framework에서의 Annotation\r런타임 처리: 어노테이션을 사용하여 런타임에 동적으로 처리할 수 있는 정보를 제공합니다. 예를 들어, 스프링 프레임워크에서 @Autowired 어노테이션은 의존성 주입(Dependency Injection)을 위해 사용됩니다.\n코드 분석 도구와의 통합: 어노테이션을 사용하여 코드를 분석하고 검증하는 도구와 통합할 수 있습니다. 예를 들어, 테스트 코드에서 특정 메서드에 대한 테스트를 자동으로 생성하기 위해 JUnit은 @Test 어노테이션을 사용합니다.\n#\rSpring Boot 어노테이션 정리\r@Setter, @Getter\n클래스의 필드에 대해 set, get 메서드를 자동으로 만들어줌\n@Entity\n해당 클래스가 데이터베이스 테이블과 매핑되는 엔티티 클래스임을 명시, JPA가 해당 클래스를 데이터베이스의 테이블과 매핑할 수 있도록 지정\n@RequiredArgsConstructor\n해당 클래스의 필드를 기반으로 한 생성자를 자동으로 생성.\n이 생성자는 해당 클래스의 final로 선언된 필드들을 매개변수로 받으며, 객체를 생성할 때 이러한 필드들에 대한 초기화를 수행.\n@Autowired\n의존성 주입(Dependency Injection)을 지정하는 데 사용.\n스프링 컨테이너는 @Autowired가 붙은 필드나 메서드의 매개변수에 해당하는 빈(Bean)을 찾아서 주입.\n참고 : 스프링에서는 필드 주입을 사용할 때 일반적으로 \u0026lsquo;final\u0026rsquo; 키워드를 사용할 수 없음.\n@GetMapping\n매핑될 URL을 지정하는데 사용. value= 는 생략 가능\n@Bean\n애플리케이션1 컨텍스트에 의해 관리되는 객체. IoC 컨테이너에 의해 생성, 조립, 관리됨.\nConfiguration\n스프링 애플리케이션 컨텍스트에 대한 구성 클래스를 선언하는 데 사용. 자바 클래스를 스프링의 구성 클래스로 선언할 수 있음.\n@EnableWebSecurity\n스프링 시큐리티에서 사용되는 애노테이션으로, 웹 보안 설정을 활성화하는 데 사용한다.\n@EnableMethodSecurity 메소드 호출에 대한 보안 규칙을 정의하고 적용하는 데 사용하는 어노테이션 prePostEnabled 속성을 true로 설정하면 @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter 어노테이션을 활성화할 수 있다.\n@PreAuthorize(\u0026ldquo;isAuthenticated()\u0026rdquo;) 메소드가 호출되기 전에 미리 정의된 보안 조건을 검사 isAuthenticated()을 사용하면 현재 사용자의 인증여부를 확인하는 데 사용할 수 있음.\n@SpringBootTest\n스프링 컨테이너와 테스트를 함께 실행함\n@Transactional\n테스트 케이스에 이 어노테이션이 있으면 테스트 시작 전에 트랙잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. DB에 데이터가 남지 않아서 다음 테스트에 영향을 주지 않음.\n빈(Bean) 관리, 의존성 주입(Dependency Injection), 생명주기 관리를 담당하는 컨테이너.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-02-21T00:00:00+09:00","image":"http://localhost:1313/cover/springboot.png","permalink":"http://localhost:1313/article/spring-boot-annotation-overview/","title":"스프링부트 @Annotation 정리"},{"content":"\r#\r서론\r디자인 패턴을 몰라도 코딩은 할 수 있다. 하지만 트러블 슈팅에 있어 디자인 패턴도 고려해볼 수 있는가는 개발자의 유능함을 가를 수 있다고 생각한다.\n#\r디자인 패턴이란?\r소프트웨어 디자인 과정에서 자주 발생하는 문제들에 대한 전형적인 해결책이다. 알고리즘도 문제에 대한 해결책이지만, 명확한 일련의 절차를 정의하는 알고리즘과는 달리 패턴은 문제에 대한 결과와 기능은 제시하나 구현 단계 및 순서는 사용자가 결정하게 된다.\n한마디로, 특정 문제를 해결하는 방식에 대한 이론이다.\n#\r패턴의 역사\r패턴은 되풀이되는 사건이나 물체의 형태를 말한다. 일반적인 문제들에 대한 반복적으로 사용되는 해결책이 개념화된 것이 디자인 패턴이다.\n패턴이라는 개념은 도시 건축에서 처음 등장한다. 상황에 따라 창문의 높이와, 건물의 층수 등을 설명할 때 제시되었으며 이는 곧 에릭 감마, 존 블리시디스, 랄프 존슨, 리처드 헬름의 4명의 작가에게 정리된다(Gang of Four \u0026gt; GoF)\n23가지 패턴을 시작으로 현재는 수많은 패턴들이 발견되고 있다.\n#\r왜 패턴을 배워야 하는가\r#\r문제의 해결\r지금까지 엔지니어들이 소프트웨어를 디자인하며 발생된 일반적인 문제들에 대해 시도하고 검증된 해결책의 모음집이다. 패턴들을 인지하고 있다면 문제의 해결뿐 아니라, 다양한 종류의 문제를 해결할 때에도 응용할 수 있을 것이다.\n#\r의사소통\r디자인 패턴을 알고 있다면 개념들을 설명할 필요 없이 정의된 공통 언어를 통해 소통할 수 있다. 예를 들어, 싱글턴 패턴의 개념을 나열할 필요 없이 “싱글턴 패턴을 적용해보세요”라고 말할 수 있을 것이다.\n#\r패턴에 대한 비판\r모든 상황에 패턴을 적용할 필요는 없다.\n#\r패턴의 분류\r#\r적용 범위에 따라\r하위 설계 패턴(이디엄) : 단일 프로그래밍 언어에만 적용할 수 있다. 상위 설계 패턴(아키텍처 패턴) : 어플리케이션 전체의 구조를 설계하는 데 사용 #\r의도와 목적에 따라\r생성 패턴 : 기존 코드의 재활용과 유연성을 증가시키는 객체 생성 메커니즘들을 제공 구조 패턴 : 구조를 유연하고 효율적으로 유지하면서 객체와 클래스를 더 큰 구조로 조합하는 방법을 설명 행동 패턴 : 객체 간의 효과적인 의사소통과 책임 할당을 처리 ","date":"2024-02-18T00:00:10+09:00","image":"http://localhost:1313/cover/designpattern.png","permalink":"http://localhost:1313/article/design-patterns-intro/","title":"디자인 패턴이란?"},{"content":"원글 링크\n#\r원글 요약\r쿠폰에 대해 \u0026ldquo;주문 상품에 사용할 수 없는 쿠폰입니다\u0026quot;라는 보고가 들어옴. 사용할 수 없는 쿠폰을 사용 시도한 경우로 사용자 UI 상에서는 이뤄질 수 없는 시스템 오류 혹은 공격의 가능성이 있는 현상이기 때문에 분석 진행 zipkin을 통해 사용자 정보와 쿠폰 정보 확인 kibana를 통해 API 로그 조회 주문서 단계에서 쿠폰은 사용 가능이었지만 결제 단계에서는 사용 불가능했음. 원인은 주문서 단계에서 쿠폰의 사용조건이 충족되었으나 결제 단계로 넘어갈 때 상품 할인에 변동이 있었기에 사용 조건이 충족되지 못하게 되었던 것이다.\n이는 쿠폰 사용이 되지 않도록 어플리케이션에서 잘 방어한 것을 검증 할 수 있는 케이스였고, 불편한 사용자 경험에 대해 컬리는 다음과 같이 멘션을 남겼다.\n할인가의 변화 혹은 증정 프로모션의 종료로 인해서 사용자가 장바구니에 담았을 당시와 결제시에 정보차이로 생기는 문제가 종종있어서 개선 계획에 있습니다. 😀\n#\rZipkin\rZipkin은 분산 시스템에서 발생하는 문제를 해결하고, 시스템 내에서의 요청 흐름을 추적하는 데 사용되는 오픈 소스 분산 추적 시스템이다. 주로 마이크로서비스 아키텍처1와 같이 여러 서비스 간 통신이 발생하는 환경에서 사용된다.\nZipkin은 각각의 서비스에서 발생하는 요청을 추적하기 위해 서비스 간에 고유한 식별자를 사용한다. 각 요청은 이 식별자를 통해 추적되며, 요청이 서비스 간을 이동할 때마다 해당 요청에 대한 정보가 업데이트된다.\nZipkin을 사용하면 다음과 같은 장점을 얻을 수 있다.\n문제 해결 및 디버깅 : 시스템에서 발생하는 문제를 식별하고 디버깅하는 데 도움이 된다. 성능 분석 : 각 서비스 간의 요청 및 응답 시간을 추적하여 성능 향상을 위한 지표를 제공한다. 서비스 의존성 시각화 : 서비스 간의 의존성을 시각화하여 시스템 아키텍처를 이해하고 변경사항을 관리하는 데 도움이 된다. 종합하면, Zipkin은 분산 시스템에서의 추적과 모니터링을 통해 시스템의 가시성을 높이고, 문제를 해결하고 성능을 향상시키는 데 도움이 되는 유용한 도구이다.\n#\rKibana\rKibana는 Elastic Stack2의 한 부분으로, 대규모 데이터 집합을 시각화하고 분석하는 데 사용되는 오픈 소스 데이터 시각화 도구이다. 주로 대용량 로그 파일, 지표 및 기타 유형의 데이터를 탐색하고 이해하는 데 사용된다.\n#\r주요기능\r대시보드 작성 : 사용자는 다양한 시각화 요소를 조합하여 사용자 정의 대시보드를 만들 수 있다. 이를 통해 데이터의 시각적인 요약과 인사이트를 얻을 수 있다. 시각화 : Kibana는 다양한 종류의 차트와 그래프를 생성할 수 있다. 선 그래프, 막대 차트, 파이 차트, 지리적 지도 등 다양한 형태의 시각화를 제공한다. 데이터 탐색 및 검색 : Elasticsearch3의 강력한 검색 기능과 연동되어, 사용자는 데이터를 쉽게 탐색하고 검색할 수 있다. 필터링 및 집계 : Kibana를 사용하여 데이터를 필터링하고 집계하여 원하는 정보를 추출하고 분석할 수 있다. 시계열 분석 : Kibana는 시계열 데이터를 처리하고 분석하는 데 강력한 기능을 제공한다. 이는 로그 데이터 및 시스템 성능 모니터링과 같은 시나리오에 유용하다. 사용자 관리 및 권한 부여 : Kibana는 다중 사용자 환경에서 작동하며, 사용자에게 액세스 수준 및 권한을 부여할 수 있다. Kibana는 로그 분석, 시스템 모니터링, 비즈니스 인텔리전스 등 다양한 용도로 사용된다. 그 유연성과 사용자 친화적인 인터페이스는 데이터 분석 및 시각화 작업을 쉽게 수행할 수 있도록 지원한다.\n#\r마치며\rKurly에서는 오류, 또는 문제 분석에 있어 Zipkin을 사용해 요청에 대해 필요한 정보를 찾아내고(사용자 정보, 쿠폰 정보) 이를 통해 Kibana에서 API 호출에 대한 로그를 조회하여 분석한다는 것을 알 수 있었다.\n소프트웨어를 작은, 독립적인 서비스로 나누어 개발하고 관리하여 유연성과 확장성을 높이는 아키텍처 패턴이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n검색, 분석, 시각화, 로깅 등 다양한 데이터 처리를 위한 오픈 소스 도구 모음이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n실시간 분산 검색 및 분석 엔진으로, 대용량 데이터를 저장하고 검색하며 시각화하는 데 사용된다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-02-18T00:00:05+09:00","image":"http://localhost:1313/article/kurly-zipkin-kibana-review/cover.png","permalink":"http://localhost:1313/article/kurly-zipkin-kibana-review/","title":"[Kurly] 쿠폰과 할인으로 앞다리살 하나 더 판매한 이야기 - 리뷰"},{"content":"Client - Server 간에 사용자 인증을 위해 보편적으로 Cookie \u0026amp; Session나 토큰 인증 방식을 사용한다.\n어떤 상황에 어떤 방식을 적용하는 지 궁금하여 정보를 찾아보다 재미있는 글을 발견했다. 위 글을 읽으며 쿠키와 세션, JWT에 대해 정리해봤다.\n#\r기본 지식\r#\rHTTP 프로토콜\r사용자 인증, 사용자 정보 확인이 필요한 이유는 HTTP의 프로토콜의 특징에 있다.\nconnectionless : 클라이언트가 서버에 요청을 보내면 서버는 응답을 제공하고, 그 후에는 클라이언트와 서버 간의 연결이 바로 종료된다.\nstateless : 서버가 클라이언트의 이전 상태를 기억하지 않는다. 즉, 서버는 요청을 받고 처리한 후 클라이언트에 대한 추가 정보를 유지하지 않는다.\nstateless의 특징으로 인해 페이지 이동이나 브라우저의 재접속 시 사용자 정보가 남아있지 않게 된다.\n정적 웹페이지라면 사용자 정보를 핸들링할 필요가 없겠지만, 사용자 정보가 유지되어야 하는 경우 쿠키, 세션 등을 이용하게 된다.\n#\r쿠키와 세션\r쿠키 : 서버가 클라이언트로 보내는 작은 정보 조각이다. 브라우저의 Cookie Storage에 저장되며 일반적으로 authentication, personalization1, tracking에 사용된다.\n쿠키는 HttpOnly 설정을 해 JavaScript를 통한 접근을 제한할 수 있고, 이로써 XSS 공격에 대해 안전할 수 있다.\n세션 : 쿠키를 기반으로 사용자 정보를 브라우저가 아닌 서버에서 관리한다. 따라서, 사용자가 많아질수록 서버의 성능저하를 유발할 수 있다.\n쿠키 세션 저장 위치 클라이언트(브라우저) 서버 보안 취약 강함 라이프 사이클 만료시점 시 삭제 브라우저 종료 시 삭제 속도 빠름 느림 저장 형식 Text Object #\rXSS와 CSRF\rXXS(Cross-Site Scripting) : Local Storage등의 Web Storage는 JavaScript를 통해 접근이 가능하다. 이 때문에 공격자가 사이트에 스크립트를 넣어 쿠키, 세션 토큰 등의 민감한 정보를 탈취할 수 있다.\nCSRF(Cross-Site Request Forgery) : 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 서버에 요청하게 하는 공격이다. 브라우저는 모든 request에 자동적으로 쿠키를 함께 보내기 때문에, 해당 쿠키로 주어진 접근 권한으로 브라우저를 신용하는 사이트를 공격하는 것이다.\n#\rStorage\rCookies Storage : 클라이언트 저장소로 HTTP 쿠키가 저장되는 곳이다. CSRF에서 서술했지만, request를 보낼 때 cookie request header에 자동적으로 쿠키 포함하여 보내기 때문에 CSRF에 취약하다.\nWeb Storage : Local Storage 또는 Session Storage를 말한다. 역시 클라이언트 저장소이며, key-value 구조의 데이터를 저장하는데 이용한다. XSS공격에 취약하다. JavaScript를 통해 데이터를 가져올 수 있기 때문에 XSS에 취약하며, private/sensitive/authentication와 관련된 데이터는 저장하지 않는 것이 권장된다.\nCookies Storage Local/Session Storage JavaScript HttpOnly설정을 통해 접근 제한 가능 같은 도메인에서 JavaScript를 통해 접근 가능 XSS 면역 취약 CSRF 취약 면역 해결책 CSRF token을 이용하거나 기타 방법 민감한 정보는 저장하지 않는 것이 권장 #\rJWT\rJWT(JSON Web Tokens)는 토큰의 한 종류로 일반적으로 인증과 권한 부여에 이용되며, 보통 Local Storage나 Cookie에 저장된다. 토큰의 형태를 보면 암호화되어 있는 것 같지만, Base64 인코딩되어 있을 뿐이다.\n#\r왜 JWT를 사용하는가?\rJWT를 사용하면 horizontal scaling2이 쉬워지기에 token-based authentication에 자주 이용된다. 그 이유는 토큰의 검증에 있어 서버와 데이터베이스 간의 통신이 필요없기 때문이다.\n아래는 프로젝트에서 JWT를 적용한 예시이다.\n클라이언트(Flutter)에서 데이터 요청 시 사용자 검증 후 데이터를 전달하는 로직에서, JWT를 이용하면 데이터베이스로의 I/O 없이 사용자 검증을 구현할 수 있다.\n#\r쿠키와의 비교는 무의미하다.\rJWT는 토큰의 형식일 뿐이고, 쿠키는 HTTP 상태 관리 메커니즘(HTTP State Management Mechanism)일 뿐이다.\n쿠키는 JWT를 포함할 수 있고 이는 JWT가 Cookies Storage에 저장될 수 있음을 의미한다.\n#\rToken-based vs Session-based\r올바른 비교는 \u0026ldquo;token-based 인증과 Session-based 인증의 차이는 무엇인가?\u0026rdquo; 이다.\nTOKEN-BASED SESSION-BASED Statefulness Stateless stateful 인증 상태 관리 서버에 저장하지 않음 서버에 저장(DB) 수평적 확장 쉬움 어려움 인증 방법 보통 JWT를 사용 Session ID 사용 서버 전송 방법 HTTP Request Authorization Header, Cookie Cookie request header 세션 종료 어려움 쉬움 인증과 관련된 정보를 서버에 저장하지 않아도 되고, 수평적 확장이 용이한 점 때문에 토큰 기반 인증이 선호된다.\n#\rBearer Tokens\rBearer token은 HTTP request의 Authorization header에 들어가는 토큰이다. Authorization header는 쿠키와는 달리 request 요청에 자동으로 포함되지 않기 때문에 CSRF 방어에 효과적이다. 그리고 토큰은 요청 시 토큰을 보내기 위해 클라이언트 측에 저장되어 있어야 한다. 하지만 Local Storage에 저장해두면 XSS에, Cookie에 저장하면 CSRF에 취약하게 된다.\n#\r마치며\r프로그램이나 서비스의 목적에 따라 다르겠지만 최근에는 토큰 인증 방식을 많이 사용하는 것으로 보인다. 하지만 토큰 인증 방식은 보안에 취약한 부분이 있기 때문에 공격에 대한 준비가 되어 있어야 한다. 토큰을 어디에 저장하느냐는 개발자의 성향(?)과 시스템의 설계에 따라 다른 것 같다. 아래는 CSRF에 대비하는 한가지 예시이다.\n사용자가 로그인하면 서버는 JWT를 발급하고 JWT안에 csrfToken을 저장한다. 생성된 csrfToken은 예측할 수 없고 각 사용자 세션마다 고유해야 한다.\n그 다음 JWT는 쿠키로써 Set-Cookie response header 에 설정한다. 반면에 무작위로 생성된 csrfToken은 X-CSRF-Token response header에 설정된다.\n브라우저는 JWT를 Cookies Storage에 저장하고 X-CSRF-Token header에 있는 csrfToken은 브라우저의 Local Storage에 저장된다.\n요청이 일어나면(예: GET /hello), 브라우저는 Local Storage에서 csrfToken을 가져온다.\nCookies Storage의 JWT와 Local Storage에서 가져온 csrfToken은 request header에 담겨 서버로 보내진다.\n서버는 JWT를 확인하고 request header의 csrfToken과 JWT 안의 토큰이 일치하는 지 대조한다.\nCookies Storage와 Local Storage에 각각 토큰을 저장하여 검증하는 방식이며 공격에 대비하는 유효한 방어책이라고 생각한다. JWT의 Refresh Token까지 적절히 사용한다면 높은 수준의 보안성을 가질 수 있지 않을까?\n소비자의 이름, 관심사, 과거 구매이력을 기반으로 시장에 전달할 메시지를 조정하여 특정 고객에 맞는 마케팅 메시지를 만들어내는 것을 말한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n단일 대형 서버 대신 여러 작은 서버 또는 인스턴스로 시스템을 확장하는 기술이다. Docker와 Kubernetes가 핵심 개념 중 하나이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-02-17T10:00:00+09:00","image":"http://localhost:1313/article/cookie-session-jwt/cover.png","permalink":"http://localhost:1313/article/cookie-session-jwt/","title":"쿠키 세션 JWT 정리"},{"content":"\r#\r캐싱이란?\r캐싱은 데이터나 계산 결과를 임시 저장소에 저장하는 프로세스를 말한다. 이는 데이터나 계산 결과를 나중에 빠르게 검색하거나 재사용할 수 있게 해준다.\n캐싱은 방법에 따라 메모리나 디스크, DB등에 저장할 수 있다. 내 프로젝트는 현재 sqlite3이라는 내장DB를 하는데, 보통은 DB서버를 두는 게 일반적이다. 따라서 테스트를 위해 DB서버를 열고 연결해 주었다.\n#\r분석에 사용한 도구\rPostman : 단일 API 호출과 Runner를 이용해 테스트를 진행했다. Django-debug-toolbar : SQL이 어떻게 호출되는지 확인하는 데 사용했다. #\r전체공개 게시글 리스트를 호출하는 API\r글 : 10000개 #\r개선 전\r현재는 API를 호출할 때마다 쿼리 호출을 통해 DB에서 데이터를 받아 전달한다.\n#\r개선 과정\r#\rRedis\rRedis는 메모리 기반의 데이터 저장소이자 오픈 소스의 키-값 데이터 구조 저장소이다. 이를 이용하여 전체공개 게시글에 대해 캐싱을 해두고,데이터에 대해 변경이 있을 때만 업데이트했다.\n#\r왜 전체 공개 게시글인가?\r캐싱을 이용하는 이유는\n데이터 액세스 빈도가 높은 경우 네트워크 대역폭 절약 서버 부하 감소 실시간성이 필요하지 않은 데이터 정도로 볼 수 있다. 그중 전체 게시글에 적용한 이유는 다음과 같다.\nFUNSUN의 특성상 전체 공개 게시글의 업데이트 빈도는 낮으리라 예상했다. 검색 화면으로 진입 시 보여야 하는 데이터이기에 호출 빈도가 높을 것이라고 예상했다. #\r고려 사항\r캐싱 제한\n광고등의 도배성 게시글로 인해 public 게시글에 대해 짧은 시간에 많은 POST 요청이 생길 수 있다는 약점을 고려하고 싶었기에 업데이트가 필요할 시 5초에 한번만 캐싱하게끔 제한을 걸었다. 코드의 작성\nREAD를 제외한 CUD함수마다 코드를 중복하여 작성하고 싶지 않았기에 처음에는 미들웨어에서 제어하려고 했다. 하지만 이 방법은 요청 시 수행되는 작업이기 때문에 정작 업데이트되야 하는 정보가 반영이 안됐다. 이는 Funding 모델에 update_cache_if_public함수를 만들어 중복을 최소화했다. #\r개선 후\rRedis를 통해 데이터베이스 호출 없이 게시글을 불러옴으로써 Response Time을 줄일 수 있었다.\n#\r추가 내용\r#\r추가적으로 적용될 수 있는 API는 무엇이 있을까\r사용자 프로필 : 정보를 한번 등록하면 업데이트가 자주 일어나지 않는다. 펀딩한 게시글 리스트 : 개인 마다의 업데이트 빈도가 짧지 않다. #\r데이터 중복에 대하여\r결국 캐싱을 한다는 것은 사실 데이터를 중복으로 가지고 있는 것과 같다. 디스크과 메모리에 있어서 리소스 낭비가 일어날 수 있기에 캐싱을 남발하는 것은 주의해야 할 것 같다. 적절한 데이터를 엄선하여 캐싱하는 것이 캐싱을 구현하는 것보다 훨씬 어려웠다.\n","date":"2024-02-16T00:00:00+09:00","image":"http://localhost:1313/cover/django.png","permalink":"http://localhost:1313/article/django-api-improvement-cache/","title":"[Django] API 성능을 개선해보자 : 캐싱"},{"content":"\r#\rN+1 문제란?\rN+1 문제는 데이터베이스 쿼리를 처리하는 동안 발생할 수 있는 성능 문제 중 하나다.\n테이블의 데이터(댓글)을 가져오기 위해 쿼리를 실행한다(N번). 각 데이터 마다 추가 정보(작성자)를 가져오기 위해 별도의 쿼리를 실행한다(1번). 결과적으로 N번의 실행 이후 N개의 추가 쿼리 실행이 일어난다. #\r분석에 사용한 도구\rPostman : 단일 API 호출과 Runner를 이용해 테스트를 진행했다. Django-debug-toolbar : SQL이 어떻게 호출되는지 확인하는 데 사용했다. #\r단일 게시글의 댓글을 호출하는 API\r댓글 : 100개 #\r개선 전\r쿼리를 202번이나 호출한다.\n#\r개선 과정\r#\rselect_related()와 prefetch_related()\rselect_related() : 일대일 및 외래 키 관계에 사용하며, 단일 쿼리를 사용하여 관련된 객체를 가져온다. prefetch_related() : 다대다 및 역방향 관계에 사용하며, 별도의 추가 쿼리를 사용하여 관련된 객체를 가져와 메모리에서 조합한다. 나의 경우, 외래 키 관계였기에 select_related()를 이용하여 댓글 데이터를 가져올 때 작성자에 대한 정보도 미리 로드하여 추가적인 쿼리 호출을 막았다.\n그럼에도 쿼리 호출 결과는 202→102번으로 만족스럽지 못했고, 다시 검토했음에도 select_related()를 포함한 함수안에서는 특별히 이상이 있는 코드는 없었다. 문제를 파악하기 위해 댓글 객체를 이용하는 코드들을 따라가 분석해보니 serializer가 데이터를 직렬화하는 과정에서 그 이유를 찾을 수 있었다.\n댓글의 작성자 정보를 추가할 때 쿼리 호출을 하고 있었고, 이는 외래키 참조를 통해 해결했다.\n민망한 코드였다.\n#\r개선 후\r쿼리 호출 수를 비약적으로 줄인 결과 평균 응답 시간이 10배 넘게 줄었다.\n페이징을 통해 한 번에 8개의 댓글만 불러오게 수정해 추가적으로 성능 개선을 했다.\ndjango에서 제공하는 Paginator라이브러리는 카운팅 쿼리 호출이 강제적이어서 함수를 새로 작성했다.\n편리하고 재미있는 기능을 많이 구현하더라도 서버에 과부하가 오는 등 문제가 생기면 쓸 수 없다.\n차라리 견고하고 단단한 기능 하나가 더 유용하리라 느꼈다.\n#\r추가 내용\r게시글이 존재하는데 댓글이 없어서 빈 배열 return 게시글이 존재하지 않아 빈 배열 return 현재 두 가지 상황을 구분하기 위해 API 요청 시 게시글 확인을 위해 쿼리 선택을 한 번 진행한다. 게시글에 대해서 댓글은 cascade 관계이므로 이 과정을 생략할지 고민 중이다.\n#\r팔로우 중인 사람들의 게시글 리스트 API\r글 : 10000개 #\r개선 전\r포스트맨으로 테스트를 진행하면 사고가 날 것을 예상해 단일 호출만 해봤다.\n처리 시간만 4680.86ms가 걸린다.\n#\r개선 과정\r쿼리에 대한 조건을 나누어 생각했다. 내가 팔로우 하는 사람의 전체 공개 게시글 서로 팔로우 하는 사람의 친구 공개 게시글 두가지로 나누어 이에 대한 쿼리문을 작성 후 OR 연산을 통해 합쳤다.\nselect_related() 메서드를 이용하며 remit과 동일하게 serializer 부분을 수정해주었다. 아래는 코드이다.\n1 2 3 4 5 6 7 8 9 10 11 12 #내가 팔로우한 사람들 followee_users = Follow.objects.filter(follower=user.id).values_list(\u0026#39;followee\u0026#39;) #나를 팔로우한 사람들 follower_users = Follow.objects.filter(followee=user.id).values_list(\u0026#39;follower\u0026#39;) # 사용자가 팔로우한 사용자들의 펀딩 가져오기 fundings = Funding.objects.filter( Q(author__in=followee_users) \u0026amp; (Q(public=True) | # 내가 팔로우한 사람들의 공개 펀딩 (Q(public=False)\u0026amp;Q(author__in=follower_users))) # 비공개 펀딩 중 사용자가 작성자를 팔로우한 경우 ).order_by(\u0026#39;-created_on\u0026#39;).select_related(\u0026#39;author\u0026#39;) #\r개선 후\r중복 쿼리를 없앴으며, 속도가 33.39ms 로 비약적으로 상승했다.\n이후 페이징 처리를 통해 12.19ms까지 향상 시켰다.\n","date":"2024-02-15T00:00:00+09:00","image":"http://localhost:1313/cover/django.png","permalink":"http://localhost:1313/article/django-api-improvement-nplus1/","title":"[Django] API 성능을 개선해보자 : N+1문제"},{"content":"\r#\r상속간 함수 오버라이딩\r기본(Base) 클래스에서 정의한 멤버함수를 파생(Derived) 클래스에서 재정의 하는 것.\n리턴형, 함수이름, 매개변수정보 모두 같아야 함.\n#\r객체 포인터와 함수호출\r객체 포인터를 기준으로 객체를 인식한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: void f() { cout \u0026lt;\u0026lt; \u0026#34;Base::f()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: void f() { cout \u0026lt;\u0026lt; \u0026#34;Derived::f()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(void) { Derived d, * pDer; pDer = \u0026amp;d; Base* pBase; pBase = \u0026amp;d; pDer-\u0026gt;f(); pBase-\u0026gt;f(); return 0; } /* Derived::f() Base::f() */ C++ 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단하며 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다.\n#\r가상함수\r객체 포인터 기준을 객체 기준으로 바꿔주는 문법. 함수 오버라이딩에서 사용 가능하다.\nvirtual 키워드를 사용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; class First { public: void MyFunc() { cout \u0026lt;\u0026lt; \u0026#34;FirstFunc()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Second : public First { public: virtual void MyFunc() { cout \u0026lt;\u0026lt; \u0026#34;SecondFunc()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Third : public Second { public: void MyFunc() { cout \u0026lt;\u0026lt; \u0026#34;ThirdFunc()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(void) { Third* tptr = new Third(); Second* sptr = tptr; First* fptr = sptr; tptr-\u0026gt;MyFunc(); sptr-\u0026gt;MyFunc(); fptr-\u0026gt;MyFunc(); delete tptr; return 0; } /* ThirdFunc() ThirdFunc() 원래는 secondFunc()이었지만 virtual 키워드를 통해 객체 기준으로 바뀜 FirstFunc() */ #\r추상 클래스\r객체화 시킬 수 없는 클래스, 객체화시킬 목적으로 만든 클래스가 아님.\n\u0026gt; 상속으로 확장하기 위해 만든 클래스\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; class First //순수 가상함수를 하나 이상 가지는 클래스는 추상클래스가 된다. { public: virtual void MyFunc() = 0; //순수 가상함수 }; class Second : public First { public: void MyFunc() { cout \u0026lt;\u0026lt; \u0026#34;SecondFunc()\u0026#34; \u0026lt;\u0026lt; endl; } }; class Third : public Second { public: void MyFunc() { cout \u0026lt;\u0026lt; \u0026#34;ThirdFunc()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(void) { Third* tptr = new Third(); Second* sptr = tptr; First* fptr = sptr; tptr-\u0026gt;MyFunc(); sptr-\u0026gt;MyFunc(); fptr-\u0026gt;MyFunc(); delete tptr; return 0; } /* ThirdFunc() ThirdFunc() FirstFunc() */ #\r추상 클래스 예시\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 다음 추상 클래스 Calculator를 상속 받아 GoodCalc 클래스를 구현. 단 Calculator는 덧셈, 뺄셈 기능을 하는 함수를 반드시 지닌다. GoodCalc는 평균을 내는 기능을 하는 함수를 반드시 지닌다. */ #include \u0026lt;iostream\u0026gt; using namespace std; class Calculator { public: Calculator() {} int add(int a, int b) { return a + b; } int subtract(int a, int b) { return a - b; } virtual double average(int* a, int b) = 0; }; class GoodCalc : public Calculator { public: double average(int* a, int b) { double tmp = 0; for (int i = 0; i \u0026lt; b; i++) { tmp += a[i]; } return tmp / 5; } }; int main(void) { int a[] = { 1,2,3,4,5 }; Calculator* p = new GoodCalc(); cout \u0026lt;\u0026lt; p-\u0026gt;add(2, 3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p-\u0026gt;subtract(2, 3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p-\u0026gt;average(a, 5) \u0026lt;\u0026lt; endl; delete p; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;iostream\u0026gt; using namespace std; class Shape { string name; int width, height; public: Shape(string n = \u0026#34;\u0026#34;, int w = 0, int h = 0) { name = n; width = w, height = h; } virtual double getArea() = 0; string getName() { return name; } int getW() { return width; } int getH() { return height; } }; class Oval : public Shape { public: Oval(string n, int w, int h) :Shape(n, w, h) {}; double getArea() { return getW() * getH() * 0.25 * 3.14; } }; class Rect : public Shape { public: Rect(string n, int w, int h) :Shape(n, w, h) {}; double getArea() { return getW() * getH(); } }; class Triangular : public Shape { public: Triangular(string n, int w, int h) :Shape(n, w, h) {}; double getArea() { return getW() * getH() * 0.5; } }; int main(void) { Shape* p[3]; p[0] = new Oval(\u0026#34;빈대떡\u0026#34;, 10, 20); p[1] = new Rect(\u0026#34;찰떡\u0026#34;, 30, 40); p[2] = new Triangular(\u0026#34;토스트\u0026#34;, 30, 40); for (int i = 0; i \u0026lt; 3; i++) { cout \u0026lt;\u0026lt; p[i]-\u0026gt;getName() \u0026lt;\u0026lt; \u0026#34; 넓이는 \u0026#34;; cout \u0026lt;\u0026lt; p[i]-\u0026gt;getArea() \u0026lt;\u0026lt; endl; } for (int i = 0; i \u0026lt; 3; i++) { delete p[i]; } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 #include \u0026lt;iostream\u0026gt; using namespace std; class Employee { char name[20]; public: Employee(const char name[20] = \u0026#34;anonymous\u0026#34;) { strcpy_s(this-\u0026gt;name, 20, name); } void GetInfo() { cout \u0026lt;\u0026lt; \u0026#34;name : \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } virtual double GetPay() = 0; virtual void ShowSalaryInfo() = 0; }; //정규직 클래스(고용직) class PermanentWorker : public Employee { char type[16] = \u0026#34;PermanentWorker\u0026#34;; int salary; public: PermanentWorker(const char name[20], int salary) : Employee(name) { this-\u0026gt;salary = salary; } void ShowSalaryInfo() { GetInfo(); cout \u0026lt;\u0026lt; \u0026#34;type : \u0026#34; \u0026lt;\u0026lt; type \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;salary : \u0026#34; \u0026lt;\u0026lt; GetPay() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } double GetPay() { return salary; } }; //영업직 클래스 class SalesWorker : public PermanentWorker { char type[12] = \u0026#34;SalesWorker\u0026#34;; double incentive; int salesResult; public: SalesWorker(const char name[20], int salary, double incentive) : PermanentWorker(name, salary) { salesResult = 0; this-\u0026gt;incentive = incentive; } void AddSalesResult(int i) { salesResult += i; } void ShowSalaryInfo() { GetInfo(); cout \u0026lt;\u0026lt; \u0026#34;type : \u0026#34; \u0026lt;\u0026lt; type \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;salary : \u0026#34; \u0026lt;\u0026lt; GetPay() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } double GetPay() { return PermanentWorker::GetPay() + incentive * salesResult; } }; //해외 영업직 클래스 class ForeignSalesWorker : public SalesWorker { char type[19] = \u0026#34;ForeignSalesWorker\u0026#34;; char riskRank; public: ForeignSalesWorker(const char name[20], int salary, double incentive, char riskRank) : SalesWorker(name, salary, incentive) { this-\u0026gt;riskRank = riskRank; } void ShowSalaryInfo() { GetInfo(); cout \u0026lt;\u0026lt; \u0026#34;type : \u0026#34; \u0026lt;\u0026lt; type \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;salary : \u0026#34; \u0026lt;\u0026lt; GetPay() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } double GetPay() { double pay = SalesWorker::GetPay(); if (riskRank == \u0026#39;A\u0026#39;) { return pay * 1.3; } else if (riskRank == \u0026#39;B\u0026#39;) { return pay * 1.2; } else if (riskRank == \u0026#39;C\u0026#39;) { return pay * 1.1; } else { throw range_error(\u0026#34;rank out of range\u0026#34;); } } }; //임시직 클래스 class TemporaryWorker : public Employee { char type[16] = \u0026#34;TemporaryWorker\u0026#34;; int payPerHour; int workTime; public: TemporaryWorker(const char name[20], int perPay) : Employee(name) { workTime = 0; this-\u0026gt;payPerHour = perPay; } void AddWorkTime(int workTime) { this-\u0026gt;workTime += workTime; } void ShowSalaryInfo() { GetInfo(); cout \u0026lt;\u0026lt; \u0026#34;type : \u0026#34; \u0026lt;\u0026lt; type \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;salary : \u0026#34; \u0026lt;\u0026lt; GetPay() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } double GetPay() { return payPerHour * workTime; } }; //컨트롤 클래스 class EmployeeHandler { Employee* empList[50]; int empNum; public: EmployeeHandler() { empNum = 0; } ~EmployeeHandler() { for (int i = 0; i \u0026lt; empNum; i++) { delete empList[i]; } } void AddEmployee(Employee* worker) { empList[empNum] = worker; empNum++; } void ShowTotalSalary() { double sum = 0; for (int i = 0; i \u0026lt; empNum; i++) { sum += empList[i]-\u0026gt;GetPay(); } cout \u0026lt;\u0026lt; \u0026#34;전 직원 월급 총합 : \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } //각 직원의 내역 출력 void ShowAllSalaryInfo() { for (int i = 0; i \u0026lt; empNum; i++) { empList[i]-\u0026gt;ShowSalaryInfo(); } } }; int main(void) { EmployeeHandler emp; //정규직 직원 emp.AddEmployee(new PermanentWorker(\u0026#34;kim\u0026#34;, 1000)); emp.AddEmployee(new PermanentWorker(\u0026#34;lee\u0026#34;, 1500)); emp.AddEmployee(new PermanentWorker(\u0026#34;jun\u0026#34;, 2000)); //영업직 직원 SalesWorker* seller = new SalesWorker(\u0026#34;Hong\u0026#34;, 1000, 0.1); seller-\u0026gt;AddSalesResult(7000); emp.AddEmployee(seller); //이름 기본급 인센티브 //해외 영업직 직원 ForeignSalesWorker* fseller1 = new ForeignSalesWorker(\u0026#34;Hong\u0026#34;, 1000, 0.1, \u0026#39;A\u0026#39;); //이름 기본급 인센티브 위험도 fseller1-\u0026gt;AddSalesResult(7000); emp.AddEmployee(fseller1); ForeignSalesWorker* fseller2 = new ForeignSalesWorker(\u0026#34;Yoon\u0026#34;, 1000, 0.1, \u0026#39;B\u0026#39;); //이름 기본급 인센티브 위험도 fseller2-\u0026gt;AddSalesResult(7000); emp.AddEmployee(fseller2); ForeignSalesWorker* fseller3 = new ForeignSalesWorker(\u0026#34;Lee\u0026#34;, 1000, 0.1, \u0026#39;C\u0026#39;); //이름 기본급 인센티브 위험도 fseller3-\u0026gt;AddSalesResult(7000); emp.AddEmployee(fseller3); //임시직 직원 TemporaryWorker* alba = new TemporaryWorker(\u0026#34;Jung\u0026#34;, 70); //이름 시간당Pay alba-\u0026gt;AddWorkTime(50); emp.AddEmployee(alba); emp.ShowAllSalaryInfo(); //각 직원의 내역 출력 emp.ShowTotalSalary(); //전 직원 월급총합 return 0; } ","date":"2023-11-20T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-virtual-func-abstract-class/","title":"9. 가상 함수와 추상 클래스"},{"content":"\r#\r상속(Inheritance)\r부모 클래스(KR) = super class(JAVA) = Base class(C++) 기본 클래스\n자식 클래스(KR) = sub class(JAVA) = Derived class(C++) 파생 클래스\n클래스 사이에서 상속관계 정의 기본 클래스의 속성과 기능을 파생 클래스에 물려주는 것 기본 클래스에서 파생 클래스로 갈수록 클래스의 개념이 구체화 다중 상속을 통한 클래스의 재활용성 높임 #\r파생된 클래스로부터 객체 생성 과정\r일반 : 메모리 공간 할당 -\u0026gt; 생성자 호출 및 실행\n상속받은 클래스 : 메모리 공간 할당 -\u0026gt; 파생클래스의 생성자 호출 -\u0026gt; 기본 클래스의 생성자 호출 및 실행 -\u0026gt; 파생 클래스의 생성자 실행\n#\r파생된 클래스로부터 객체 소멸 과정\r파생클래스의 소멸자 호출 및 실행 -\u0026gt; Base클래스의 소멸자 호출 및 실행 -\u0026gt; 메모리 공간 해제\nDerived 클래스로부터 객체 생성 시 Base 클래스의 생성자를 명시적으로 호출하고 싶다 \u0026gt; 멤버 이니셜라이저 이용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;생성자 A\u0026#34; \u0026lt;\u0026lt; endl; } A(int x) { cout \u0026lt;\u0026lt; \u0026#34;매개변수 생성자A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A { public: B():A(1){ cout \u0026lt;\u0026lt; \u0026#34;생성자 B\u0026#34; \u0026lt;\u0026lt; endl; } //멤버 이니셜라이저를 통해 매개변수 생성자 A 호출 및 실행 }; int main(void) { B b; return 0; } #\r상속 예제\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { char* name; int age; public: Person(const char* _name, int age) { name = new char[strlen(_name) + 1]; strcpy_s(name, strlen(_name) + 1, _name); this-\u0026gt;age = age; } void Show() { cout \u0026lt;\u0026lt; \u0026#34;이름 : \u0026#34;\u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; 나이 : \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }; class UnivStudent : public Person { char* major; public: UnivStudent(const char* name, int age ,const char* _major):Person(name, age) { major = new char[strlen(_major) + 1]; strcpy_s(major, strlen(_major) + 1, _major); } void WhoAreYou() { Show(); cout \u0026lt;\u0026lt; \u0026#34;전공 : \u0026#34; \u0026lt;\u0026lt; major \u0026lt;\u0026lt; endl; } }; int main(void) { UnivStudent kim(\u0026#34;kim\u0026#34;, 21, \u0026#34;AI\u0026#34;); kim.WhoAreYou(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; using namespace std; class Car { int gas; public: Car(int gas) { this-\u0026gt;gas = gas; } void ShowCurrentGas() { cout \u0026lt;\u0026lt; \u0026#34;잔여 가솔린 : \u0026#34; \u0026lt;\u0026lt; gas \u0026lt;\u0026lt; endl; }; }; class HybridCar : public Car { int elec; public: HybridCar(int gas, int elec) :Car(gas) { this-\u0026gt;elec = elec; } void ShowCurrentElec() { cout \u0026lt;\u0026lt; \u0026#34;잔여 전기량 : \u0026#34; \u0026lt;\u0026lt; elec \u0026lt;\u0026lt; endl; }; }; class HybridWaterCar : public HybridCar { int water; public: HybridWaterCar(int gas, int elec, int water):HybridCar(gas, elec) { this-\u0026gt;water = water; } void ShowCurrentGauge() { ShowCurrentGas(); ShowCurrentElec(); cout \u0026lt;\u0026lt; \u0026#34;잔여 워터량 : \u0026#34; \u0026lt;\u0026lt; water \u0026lt;\u0026lt; endl; }; }; int main(void) { HybridWaterCar drive(80, 100, 100); drive.ShowCurrentGauge(); return 0; } #\r접근지정자\rpublic : 외부접근(다른 클래스, main()함수) + 내부접근\nprotected : 내부접근, 외부접근 일부(자식 클래스에서는)\nprivate : 내부접근\n상속 지정 : public 상속을 받아야 protected와 public을 그대로 물려받아 main에서 호출이 가능하다.\n상속지정 Base멤버 public protected private private 접근금지 접근금지 접근금지 protected protected protected private public public protected private 멤버변수 : private 선언\n멤버함수 : public 선언\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //상속 예시 #include \u0026lt;iostream\u0026gt; using namespace std; class Book { char* title; char* isbn; int price; public: Book(const char* title, const char* isbn, int price) { this-\u0026gt;title = new char[strlen(title) + 1]; strcpy_s(this-\u0026gt;title, strlen(title) + 1, title); this-\u0026gt;isbn = new char[strlen(isbn) + 1]; strcpy_s(this-\u0026gt;isbn, strlen(isbn) + 1, isbn); this-\u0026gt;price = price; } ~Book() { delete[] title; delete[] isbn; } void ShowBookInfo() { cout \u0026lt;\u0026lt; \u0026#34;책 제목 : \u0026#34; \u0026lt;\u0026lt; title \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ISBN : \u0026#34; \u0026lt;\u0026lt; isbn \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;가격 : \u0026#34; \u0026lt;\u0026lt; price \u0026lt;\u0026lt; endl; } }; class Ebook :public Book { char* DRMKey; public: Ebook(const char* title, const char* isbn, int price, const char* DRMKey) :Book(title, isbn, price) { this-\u0026gt;DRMKey = new char[strlen(DRMKey) + 1]; strcpy_s(this-\u0026gt;DRMKey, strlen(DRMKey) + 1, DRMKey); } ~Ebook() { delete[] DRMKey; } void ShowEBookInfo() { ShowBookInfo(); cout \u0026lt;\u0026lt; \u0026#34;DRMKey : \u0026#34; \u0026lt;\u0026lt; DRMKey \u0026lt;\u0026lt; endl; } }; int main(void) { Book book(\u0026#34;좋은 C++\u0026#34;, \u0026#34;555-12345-890-0\u0026#34;, 20000); book.ShowBookInfo(); cout \u0026lt;\u0026lt; endl; Ebook ebook(\u0026#34;좋은 C++ ebook\u0026#34;, \u0026#34;555-12345-890-1\u0026#34;, 10000, \u0026#34;fdx9w0i8kiw\u0026#34;); ebook.ShowEBookInfo(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 //컨트롤 클래스 예제 #include \u0026lt;iostream\u0026gt; using namespace std; class PermanentWorker { char name[20]; int salary; public: PermanentWorker(const char name[20] = \u0026#34;anonymous\u0026#34;, int salary = 0) { strcpy_s(this-\u0026gt;name, 20, name); this-\u0026gt;salary = salary; } int GetPay() { return salary; } void ShowSalaryInfo() { cout \u0026lt;\u0026lt; \u0026#34;name : \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;salary : \u0026#34; \u0026lt;\u0026lt; salary \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } }; class EmployeeHandler //정규직 직원을 등록, 관리 클래스 ---\u0026gt; 컨트롤 클래스 { PermanentWorker* empList[50]; int empNum; public: EmployeeHandler() { empNum = 0; } ~EmployeeHandler() { for (int i = 0; i \u0026lt; empNum; i++) { delete empList[i]; } } //직원등록 void AddEmployee(PermanentWorker* e) //PermanentWorker* e = new PermanentWorker(\u0026#34;kim\u0026#34;, 1000); { empList[empNum] = e; empNum++; } //전 직원 월급 총합 void ShowTotalSalary() { int sum = 0; for(int i = 0; i\u0026lt;empNum; i++){ sum += empList[i]-\u0026gt;GetPay(); } cout \u0026lt;\u0026lt; \u0026#34;전직원 월급 총합 : \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } //각 직원의 내역 출력 void ShowAllSalaryInfo() { for (int i = 0; i \u0026lt; empNum; i++) { empList[i]-\u0026gt;ShowSalaryInfo(); } } }; int main(void) { EmployeeHandler emp; emp.AddEmployee(new PermanentWorker(\u0026#34;kim\u0026#34;, 1000)); emp.AddEmployee(new PermanentWorker(\u0026#34;lee\u0026#34;, 1500)); emp.AddEmployee(new PermanentWorker(\u0026#34;jun\u0026#34;, 1200)); emp.ShowAllSalaryInfo(); //각 직원의 내역 출력 emp.ShowTotalSalary(); //전 직원 월급총합 return 0; } #\r객체 포인터\r객체의 주소 값을 저장하는 객체 포인터 변수\nC++에서, AAA형 포인터 변수는 AAA 객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있다(객체의 주소 값을 저장할 수 있다).\n1 2 3 4 5 6 Person* p = new Person(); Person* p = new Student(); Person* p = new StudentWorker(); Student* s = new Student(); //가능 Student* s = new Person(); //불가 ","date":"2023-11-13T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-inheritance/","title":"8. 상속"},{"content":"\r#\r프렌드(Friend)\rprivate선언한 변수에 접근 가능하도록 설정해주는 키워드.\n#\r프렌드 키워드가 가능한 3가지\r#\r전역함수\r클래스 외부에 선언된 전역 함수\nfriend bool equals(Rect\u0026amp; r, Rect\u0026amp; s);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //전역함수에 대해서 #include \u0026lt;iostream\u0026gt; using namespace std; class Rect { int width, height; public: Rect(int width, int height) { this-\u0026gt;width = width; this-\u0026gt;height = height; } friend bool equals(Rect\u0026amp; r, Rect\u0026amp; s); // friend 키워드 사용 }; bool equals(Rect\u0026amp; r, Rect\u0026amp; s) { if (r.width == s.width \u0026amp;\u0026amp; r.height == s.height) return true; else return false; } int main(void) { Rect a(3, 4), b(4, 5); if (equals(a, b)) cout \u0026lt;\u0026lt; \u0026#34;equal\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;not equal\u0026#34; \u0026lt;\u0026lt; endl; return 0; } #\r다른 클래스의 멤버함수\r다른 클래스의 특정 멤버 함수\nfriend bool RectManager::equals(Rect\u0026amp; r, Rect\u0026amp; s);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //다른 클래스의 멤버함수에 대해서 #include \u0026lt;iostream\u0026gt; using namespace std; class Rect; class RectManager { public: bool equals(Rect\u0026amp; r, Rect\u0026amp; s); //선언과 정리를 분리해서 구현 }; class Rect { friend bool RectManager::equals(Rect\u0026amp; r, Rect\u0026amp; s); // friend 키워드 사용 int width, height; public: Rect(int width, int height) { this-\u0026gt;width = width; this-\u0026gt;height = height; } }; bool RectManager::equals(Rect\u0026amp; r, Rect\u0026amp; s) { if (r.width == s.width \u0026amp;\u0026amp; r.height == s.height) return true; else return false; } int main(void) { Rect a(3, 4), b(4, 5); RectManager man; if (man.equals(a, b)) cout \u0026lt;\u0026lt; \u0026#34;equal\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;not equal\u0026#34; \u0026lt;\u0026lt; endl; return 0; } #\r다른 클래스 전체\r다른 클래스의 모든 멤버 함수\nfriend class RectManager;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //다른 클래스 전체에 대해 #include \u0026lt;iostream\u0026gt; using namespace std; class Rect; class RectManager { public: bool equals(Rect\u0026amp; r, Rect\u0026amp; s); //선언과 정리를 분리해서 구현 void copy(Rect\u0026amp; r, Rect\u0026amp; s); }; class Rect { friend class RectManager; // friend 키워드 사용 int width, height; public: Rect(int width, int height) { this-\u0026gt;width = width; this-\u0026gt;height = height; } }; bool RectManager::equals(Rect\u0026amp; r, Rect\u0026amp; s) { if (r.width == s.width \u0026amp;\u0026amp; r.height == s.height) return true; else return false; } void RectManager::copy(Rect\u0026amp; r, Rect\u0026amp; s) { //write codes } int main(void) { Rect a(3, 4), b(4, 5); RectManager man; if (man.equals(a, b)) cout \u0026lt;\u0026lt; \u0026#34;equal\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;not equal\u0026#34; \u0026lt;\u0026lt; endl; return 0; } #\r연산자 중복(연산자 오버로딩)\r본래부터 있던 연산자의 의미를 재정의(함수 구현)\n멤버함수로 구현하는 방법과 전역함수로 구현하는 방법이 있다.\n#\r이항 연산(+)\r멤버함수로 구현\n클래스 안에서 구현한다.\npos1.operator+(pos2)를 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int xpos, ypos; public: Point(int xpos = 0, int ypos = 0) { this-\u0026gt;xpos = xpos; this-\u0026gt;ypos = ypos; } void showPos() { cout \u0026lt;\u0026lt; xpos \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ypos \u0026lt;\u0026lt; endl; } //지역 변수에서 생성된 객체이기 때문에 레퍼런스 사용 불가. Point operator+(Point\u0026amp; p2) { Point tmp; tmp.xpos = xpos + p2.xpos; tmp.ypos = ypos += p2.ypos; return tmp; } }; int main(void) { Point pos1(10, 20), pos2(20, 30), pos3; pos3 = pos1 + pos2; pos1.showPos(); pos2.showPos(); pos3.showPos(); return 0; } 전역함수(프렌드 함수)로 구현\noperator+(pos1, pos2)를 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int xpos, ypos; friend Point operator+(Point\u0026amp; p1, Point\u0026amp; p2); public: Point(int xpos = 0, int ypos = 0) { this-\u0026gt;xpos = xpos; this-\u0026gt;ypos = ypos; } void showPos() { cout \u0026lt;\u0026lt; xpos \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ypos \u0026lt;\u0026lt; endl; } }; Point operator+(Point\u0026amp; p1, Point\u0026amp; p2) { Point tmp; tmp.xpos = p1.xpos + p2.xpos; tmp.ypos = p1.ypos += p2.ypos; return tmp; } int main(void) { Point pos1(10, 20), pos2(20, 30), pos3; pos3 = pos1 + pos2; pos1.showPos(); pos2.showPos(); pos3.showPos(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //예제 #include \u0026lt;iostream\u0026gt; using namespace std; class Power { int kick; int punch; friend bool operator==(Power\u0026amp; p1, Power\u0026amp; p2); public: Power(int kick = 0, int punch = 0) { this-\u0026gt;kick = kick; this-\u0026gt;punch = punch; } void show() { cout \u0026lt;\u0026lt; \u0026#34;kick : \u0026#34; \u0026lt;\u0026lt; kick \u0026lt;\u0026lt; \u0026#34; punch : \u0026#34; \u0026lt;\u0026lt; punch \u0026lt;\u0026lt; endl; } Power operator+(Power\u0026amp; p2) { Power tmp(kick + p2.kick, punch + p2.punch); return tmp; } }; bool operator==(Power\u0026amp; p1, Power\u0026amp; p2) { if (p1.kick == p2.kick \u0026amp;\u0026amp; p1.punch == p2.punch) return true; else return false; } int main(void) { Power p1(1,2), p2(3, 4), p3, p4(4, 6); p3 = p1 + p2; p1.show(); p2.show(); p3.show(); p4.show(); if (p3 == p4) cout \u0026lt;\u0026lt; \u0026#34;같다\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;다르다\u0026#34; \u0026lt;\u0026lt; endl; if (p2 == p4) cout \u0026lt;\u0026lt; \u0026#34;같다\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;다르다\u0026#34; \u0026lt;\u0026lt; endl; return 0; } #\r복합대입 연산자(+=)\r멤버함수로 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int xpos, ypos; public: Point(int xpos = 0, int ypos = 0) { this-\u0026gt;xpos = xpos; this-\u0026gt;ypos = ypos; } void showPos() { cout \u0026lt;\u0026lt; xpos \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ypos \u0026lt;\u0026lt; endl; } Point\u0026amp; operator+=(Point\u0026amp; p) { xpos += p.xpos; ypos += p.ypos; return *this; } }; int main(void) { Point pos1(10, 20), pos2(20, 30), pos3; pos1.showPos(); pos2.showPos(); pos3 = pos1 += pos2; pos1.showPos(); pos3.showPos(); return 0; } 전역함수로 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int xpos, ypos; friend Point\u0026amp; operator+=(Point\u0026amp; p1, Point\u0026amp; p2); public: Point(int xpos = 0, int ypos = 0) { this-\u0026gt;xpos = xpos; this-\u0026gt;ypos = ypos; } void showPos() { cout \u0026lt;\u0026lt; xpos \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ypos \u0026lt;\u0026lt; endl; } }; Point\u0026amp; operator+=(Point\u0026amp; p1, Point\u0026amp; p2) { p1.xpos += p2.xpos; p1.ypos += p2.ypos; return p1; } int main(void) { Point pos1(10, 20), pos2(20, 30), pos3; pos1.showPos(); pos2.showPos(); pos3 = pos1 += pos2; pos1.showPos(); pos3.showPos(); return 0; } #\r단항 연산(++)\r후위 연산자\n멤버함수로 구현 : pos1.operator++(int) 전역함수로 구현 : operator++(pos1, int) 주의) 중첩 연산이 안되도록 구현해야 한다. (pos++)++; 원래 지원안됨.\n전위 연산자\n멤버함수로 구현 : pos1.operator++() 전역함수로 구현 : operator++() 주의) 중첩 연산이 되도록 구현해야 한다. ++(++pos); 원래 지원됨. 따라서 클래스\u0026amp; 형 반환\n멤버함수로 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int xpos, ypos; public: Point(int xpos = 0, int ypos = 0) { this-\u0026gt;xpos = xpos; this-\u0026gt;ypos = ypos; } void showPos() { cout \u0026lt;\u0026lt; xpos \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ypos \u0026lt;\u0026lt; endl; } Point operator++(int) { Point tmp(xpos, ypos); xpos++; ypos++; return tmp; } Point\u0026amp; operator++() { xpos++; ypos++; return *this; } }; int main(void) { Point pos1(2, 3), pos2; pos2 = pos1++; pos1.showPos(); //3, 4 pos2.showPos(); //2, 3 Point pos3(2, 3), pos4; pos4 = ++pos3; pos3.showPos(); pos4.showPos(); return 0; } 전역함수로 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int xpos, ypos; friend Point operator++(Point\u0026amp; p, int); friend Point\u0026amp; operator++(Point\u0026amp; p); public: Point(int xpos = 0, int ypos = 0) { this-\u0026gt;xpos = xpos; this-\u0026gt;ypos = ypos; } void showPos() { cout \u0026lt;\u0026lt; xpos \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ypos \u0026lt;\u0026lt; endl; } }; Point operator++(Point\u0026amp; p, int) { Point tmp = p; //Point tmp(p); Point tmp(p.xpos, p.ypos); p.xpos++; p.ypos++; return tmp; } Point\u0026amp; operator++(Point\u0026amp; p) { p.xpos++; p.ypos++; return p; } int main(void) { Point pos1(2, 3), pos2; pos2 = pos1++; pos1.showPos(); //3, 4 pos2.showPos(); //2, 3 Point pos3(2, 3), pos4; pos4 = ++pos3; pos3.showPos(); pos4.showPos(); return 0; } 후위 연산의 경우 지역 객체를 전달하기 때문에 Point를 반환\n전위 연산의 경우 둘 다 가능하지만 엄밀하게 보면 레퍼런스형을 반환하는게 옳다. 이유는 전위 연산 시 \u0026ndash;(\u0026ndash;a); 와 같이 중첩연산이 되어야 하기 때문.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; using namespace std; class Matrix { int arr[4]; public: Matrix(int a = 0, int b = 0, int c = 0, int d = 0) { this-\u0026gt;arr[0] = a; this-\u0026gt;arr[1] = b; this-\u0026gt;arr[2] = c; this-\u0026gt;arr[3] = d; } void show(){ cout \u0026lt;\u0026lt; \u0026#34;Matrix = \u0026lt; \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; arr[2] \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; arr[3] \u0026lt;\u0026lt; \u0026#34; \u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } Matrix operator+(Matrix\u0026amp; m) { Matrix tmp; for (int i = 0; i \u0026lt; 4; i++)tmp.arr[i] = arr[i] + m.arr[i]; return tmp; } Matrix\u0026amp; operator+=(Matrix\u0026amp; m) { for (int i = 0; i \u0026lt; 4; i++)arr[i] += m.arr[i]; return *this; } bool operator==(Matrix\u0026amp; m) { for (int i = 0; i \u0026lt; 4; i++)if (arr[i] != m.arr[i])return false; return true; } }; int main(void) { Matrix a(1, 2, 3, 4), b(2, 3, 4, 5), c; c = a + b; a += b; a.show(); b.show(); c.show(); if (a == c) cout \u0026lt;\u0026lt; \u0026#34;a and c are the same\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-11-06T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-friend-operator-overloading/","title":"7. 프렌드와 연산자 중복"},{"content":"\r#\r함수중복(함수 오버로딩)\r하나의 프로그램, 하나의 클래스 내에서 함수 이름을 중복해서 선언할 수 있다. 단, 매개변수가 달라야 한다.(매개변수 개수, 데이터형)\n함수 오버라이딩 : 상속에서 부모클래스에서 정의한 함수를 자식클래스에서 재정의 연산자 오버로딩 : 연산자를 내가 정의한 객체를 대상으로 동작하도록 함수 구현해 주는 것 #\r디폴트 매개변수\r매개변수가 디폴트 값을 가질 수 있음 디폴트 매개변수를 활용하면 함수 오버로딩 효과를 가질 수 있다 디폴트 매개 변수는 보통 매개 변수 앞에 선언될 수 없음\n-\u0026gt; 디폴트 매개 변수는 끝 쪽에 몰려 선언되어야 함. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //1. 함수 오버로딩 이용 //2. 디폴트 매개변수 이용 void star(int n = 5) { for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; cout \u0026lt;\u0026lt; endl; } void msg(int a, string msg = \u0026#34;hello\u0026#34;) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; endl; } int main(void) { star(); //***** star(10); //********** msg(10); //10 hello msg(10, \u0026#34;Good Morning\u0026#34;); //10 Good Morning } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void f(char w = \u0026#39; \u0026#39;, int line = 1) { for (int i = 0; i \u0026lt; line; i++) { for (int i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; w; cout \u0026lt;\u0026lt; endl; } } int main(void) { f(); //한 줄에 공백 10개 출력 f(\u0026#39;%\u0026#39;); //한 줄에 \u0026#39;%\u0026#39;를 10개 출력 f(\u0026#39;@\u0026#39;, 5);//다섯 줄에 \u0026#39;@\u0026#39;를 10개 출력 return 0; } /* %%%%%%%%%% @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ */ #\rstatic\r#\rC언어\r지역변수에 static -\u0026gt; 전역변수화(lifetime), 범위(함수 내)\nlifetime : 프로그램 시작 시 메모리 공간에 생성, 프로그램 종료 시 소멸 범위 : static변수가 선언된 함수 내에서만 접근 한번만 초기화 되고, 지역변수와 달리 함수를 빠져나가도 소멸되지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void Counter() { static int cnt; cnt++; cout \u0026lt;\u0026lt; \u0026#34;Current cnt : \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } int main(void) { for (int i = 0; i \u0026lt; 10; i++) Counter(); return 0; } #\rC++\r#\r맴버변수 static 선언 시\r클래스 변수라고 한다.\n생명주기 : 프로그램 시작 생성, 프로그램 종료 소멸, 객체 생성과 상관없이 생성 접근 범위 private : 같은 클래스에서 만들어진 객체끼리만 공유 public : 클래스와 상관없이 접근 가능 선언 : static int simObjCnt; //클래스 내에서 초기화 : int Sosimple::simObjCnt = 0; //클래스 밖에서 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; using namespace std; class SoSimple { private: static int simObjCnt; static int showCnt; //일반 멤버변수 - static으로 수정 public: static int cnt; SoSimple() { simObjCnt++; showCnt = 10; cout \u0026lt;\u0026lt; simObjCnt \u0026lt;\u0026lt; \u0026#34;번째 객체 생성\u0026#34; \u0026lt;\u0026lt; endl; } static void Show() { cout \u0026lt;\u0026lt; simObjCnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; showCnt \u0026lt;\u0026lt; endl; } }; //static 멤버변수 초기화 : 클래스 밖에서 해야함. int SoSimple::simObjCnt = 0; int SoSimple::cnt = 0; int SoSimple::showCnt = 0; int main(void) { //public 선언한 static변수는 객체와 상관없이 접근 가능. SoSimple::cnt++; cout \u0026lt;\u0026lt; SoSimple::cnt \u0026lt;\u0026lt; endl; SoSimple sim1; SoSimple sim2; SoSimple sim3; sim1.Show(); return 0; } #\r멤버함수 static 선언 시\r클래스 함수라고 한다.\n선언된 객체나 클래스 이름으로 호출(예: sim1.Show();, SoSimple::Show();)\n클래스 이름으로 호출하는 것이 더 바람직\n#\r일반멤버함수와 클래스 함수의 차이\r일반멤버함수 : static 멤버변수, 일반 멤버변수 접근, static 멤버함수 호출 가능\n클래스함수 : static 멤버변수, static 멤버함수만 호출 가능\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //예제 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { private: int money; static int sharedMoney; public: Person(int money) { this-\u0026gt;money = money; } static void addShared(int money) { sharedMoney += money; } void addMoney(int money) { this-\u0026gt;money += money; } void showMoeny() { cout \u0026lt;\u0026lt; \u0026#34;내 돈 : \u0026#34; \u0026lt;\u0026lt; money \u0026lt;\u0026lt; \u0026#34;공유 돈 : \u0026#34; \u0026lt;\u0026lt; sharedMoney \u0026lt;\u0026lt; endl; } }; int Person::sharedMoney = 0; int main(void) { Person han(100); han.addShared(200); //Person::addShared(200); 이 더 좋은 방법이다. Person lee(150); lee.addMoney(200); //lee의 개인 돈 = 350 lee.addShared(200); //static 멤버 접근, 공금 = 400 han.showMoeny(); lee.showMoeny(); return 0; } ","date":"2023-10-23T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-function-overloading-static-member/","title":"6. 함수 중복과 static 멤버"},{"content":"\r#\r호출 방식에 따른 매개변수 전달\r#\rcall by value(값에 의한 호출)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void swap(int a, int b) { int tmp = a; a = b; b = tmp; } int main(void) { int n = 10, m = 20; cout \u0026lt;\u0026lt; \u0026#34;함수 호출 전 : \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; swap(n, m); cout \u0026lt;\u0026lt; \u0026#34;함수 호출 후 : \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } #\rcall by reference(주소에 의한 호출)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp; } int main(void) { int n = 10, m = 20; cout \u0026lt;\u0026lt; \u0026#34;함수 호출 전 : \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; swap(\u0026amp;n, \u0026amp;m); cout \u0026lt;\u0026lt; \u0026#34;함수 호출 후 : \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } #\r객체 전달 방식에 따른 함수 호출\r#\r\u0026ldquo;값에 의한 호출\u0026quot;로 객체 전달\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; cout \u0026lt;\u0026lt; \u0026#34;생성자 호출\u0026#34; \u0026lt;\u0026lt; endl; } Circle(int radius) { this-\u0026gt;radius = radius; cout \u0026lt;\u0026lt; \u0026#34;생성자 호출\u0026#34; \u0026lt;\u0026lt; endl; } double getArea() { return 3.14 * radius * radius; } int getRadius() { return radius; } void setRadius(int radius) { this-\u0026gt;radius = radius; } ~Circle() { cout \u0026lt;\u0026lt; \u0026#34;소멸자 호출됨.\u0026#34; \u0026lt;\u0026lt; endl; } }; void increase(Circle c) { // 객체는 복사하여 만들어지지만 생성자 호출은 되지 않음. // 소멸자는 호출됨. cout \u0026lt;\u0026lt; \u0026#34;increase 함수 시작\u0026#34; \u0026lt;\u0026lt; endl; int r = c.getRadius(); c.setRadius(r + 1); } int main(void) { Circle waffle(30); increase(waffle); //call by value cout \u0026lt;\u0026lt; \u0026#34;increase 함수 끝\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; waffle.getRadius() \u0026lt;\u0026lt; endl; return 0; } /* 생성자 호출 increase 함수 시작 소멸자 호출됨. increase 함수 끝 30 소멸자 호출됨. */ #\r\u0026ldquo;주소에 의한 호출\u0026quot;로 객체 전달\r객체 포인터를 이용하여 객체 주소를 전달\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; cout \u0026lt;\u0026lt; \u0026#34;생성자 호출\u0026#34; \u0026lt;\u0026lt; endl; } Circle(int radius) { this-\u0026gt;radius = radius; cout \u0026lt;\u0026lt; \u0026#34;생성자 호출\u0026#34; \u0026lt;\u0026lt; endl; } double getArea() { return 3.14 * radius * radius; } int getRadius() { return radius; } void setRadius(int radius) { this-\u0026gt;radius = radius; } ~Circle() { cout \u0026lt;\u0026lt; \u0026#34;소멸자 호출됨.\u0026#34; \u0026lt;\u0026lt; endl; } }; void increase(Circle* c) { cout \u0026lt;\u0026lt; \u0026#34;increase 함수 시작\u0026#34; \u0026lt;\u0026lt; endl; int r = c-\u0026gt;getRadius(); c-\u0026gt;setRadius(r + 1); } int main(void) { Circle waffle(30); increase(\u0026amp;waffle); //call by reference cout \u0026lt;\u0026lt; \u0026#34;increase 함수 끝\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; waffle.getRadius() \u0026lt;\u0026lt; endl; return 0; } /* 생성자 호출 increase 함수 시작 increase 함수 끝 31 소멸자 호출됨. */ 예제 : Circle객체 y를 x에 더하여 x를 키우고자 한다. increaseBy() 라는 함수를 전역으로 작성하여 기능을 완성하시오.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; } Circle(int radius) { this-\u0026gt;radius = radius; } double getArea() { return 3.14 * radius * radius; } int getRadius() { return radius; } void setRadius(int radius) { this-\u0026gt;radius = radius; } void show() { cout \u0026lt;\u0026lt; \u0026#34;반지름이 \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; \u0026#34;인 원\u0026#34; \u0026lt;\u0026lt; endl; } }; void increaseBy(Circle* x, Circle* y) { int num = y-\u0026gt;getRadius(); x-\u0026gt;setRadius(x-\u0026gt;getRadius() + num); } int main(void) { Circle x(10), y(5); increaseBy(\u0026amp;x, \u0026amp;y); x.show(); return 0; } #\r객체 치환 및 객체 리턴\r객체 치환\n동일한 클래스 타입의 객체끼리 치환가능 객체의 모든 데이터가 비트 단위로 복사 치환된 두 객체는 현재 내용물만 같을 뿐 독립적인 공간 유지 객체 리턴\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Circle getCircle() { Circle tmp(30); return tmp; // 객체 tmp 리턴 } int main(void) { Circle c; c = getCircle(); //tmp 객체의 복사본이 c에 치환, c의 반지름은 30이 됨 // 다음 라인으로 넘어가면 getCircle()은 임시객체에 들어있었기 때문에(마치 상수처럼) 날라가버림. return 0; } #\r참조와 함수 (reference, 참조자)\r이름을 지니는 공간에 별칭을 부여하는 것\n자료형 \u0026amp;레퍼런스명 = 대상; 형태로 선언\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void swap(int\u0026amp; a, int\u0026amp; b) { int tmp = a; a = b; b = tmp; // 함수 호출이 끝나면 별명만 사라진다. } int main(void) { int n = 10, m = 20; cout \u0026lt;\u0026lt; \u0026#34;함수 호출 전 : \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; swap(n, m); cout \u0026lt;\u0026lt; \u0026#34;함수 호출 후 : \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; cout \u0026lt;\u0026lt; \u0026#34;생성자 호출\u0026#34; \u0026lt;\u0026lt; endl; } Circle(int radius) { this-\u0026gt;radius = radius; cout \u0026lt;\u0026lt; \u0026#34;생성자 호출\u0026#34; \u0026lt;\u0026lt; endl; } double getArea() { return 3.14 * radius * radius; } int getRadius() { return radius; } void setRadius(int radius) { this-\u0026gt;radius = radius; } ~Circle() { cout \u0026lt;\u0026lt; \u0026#34;소멸자 호출됨.\u0026#34; \u0026lt;\u0026lt; endl; } }; void increase(Circle\u0026amp; c) { cout \u0026lt;\u0026lt; \u0026#34;increase 함수 시작\u0026#34; \u0026lt;\u0026lt; endl; int r = c.getRadius(); c.setRadius(r + 1); } int main(void) { Circle waffle(20); cout \u0026lt;\u0026lt; waffle.getArea() \u0026lt;\u0026lt; endl; increase(waffle); cout \u0026lt;\u0026lt; waffle.getArea() \u0026lt;\u0026lt; endl; return 0; } /* 생성자 호출 1256 increase 함수 시작 1384.74 소멸자 호출됨. */ #\r정리\rcall by value\n객체 값에 의해 전달 생성자 매개변수 객체 생성 시 호출되지 않음 외부에서 값 변경 x call by reference\n포인터를 이용한 call by reference\n객체의 주소를 전달\n객체의 포인터가 매개변수이므로 생성자, 소멸자와 상관없음\n외부에서 값 변경 o 참조자를 이용한 call by reference #\r복사 생성자\r생성자(constructor) : 객체 생성시 반드시 한번 호출되는 함수\n복사 생성자(copy constructor) : 기존의 객체를 복사해서 새로운 객체를 생성할 때 호출되는 특별한 생성자\n중요! 참조자를 매개변수로 받아야함.\n객체를 매개변수로 받을 때 계속 객체를 생성하며 무한루프에 빠지게 된다.\ndefault 복사 생성자가 존재(기존의 멤버 변수를 복사해준다)\n특징\n한 클래스에 오직 한 개만 선언 가능 복사 생성자는 보통 생성자와 클래스 내에 중복 선언 가능 모양 : 클래스에 대한 참조 매개변수를 가지는 독특한 생성자 1 2 3 4 5 6 7 8 9 10 11 12 13 class Circle{ int radius; int x; int y; public: Circle(){this-\u0026gt;radius = 1;} Circle(int radius){ this-\u0026gt;radius = radius; } Circle(Circle \u0026amp;c){ this-\u0026gt;radius = c.radius;} }; Circle pizza; Circle waffle(10); Circle copywaffle = waffle; // Circle copywaffle(waffle); #\r얕은 복사와 깊은 복사\r얕은 복사(shallow copy)\n객체 복사 시, 객체의 멤버를 1:1로 복사 객체의 멤버 변수에 동적 메모리가 할당된 경우\n-\u0026gt; 사본은 원본 객체가 할당 받은 메모리를 공유하는 문제 발생(동적할당 해제 시 메모리 참조 오류 발생) 깊은 복사(deep copy)\n객체 복사 시, 객체의 멤버를 1:1대로 복사 객체의 멤버 변수에 동적 메모리가 할당된 경우\n- 사본은 원본이 가진 메모리 크기 만큼 별도로 동적 할당\n- 원본의 동적 메모리에 있는 내용을 사본에 복사 완전한 형태의 복사\n- 사본과 원본은 메모리를 공유하는 문제 없음 기존의 객체가 동적할당된 공간의 주소값을 가지는 경우 \u0026raquo; 반드시 깊은 복사를 하는 복사생성자를 구현해야함. 얕은 복사를 하는 default 복사 생성자로는 에러가 발생(메모리 참조 오류)\n#\r예제\r예제 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { int id; char* name; public: Person(int id, const char* name) { int name_size = strlen(name) + 1; this-\u0026gt;id = id; //동적할당 this-\u0026gt;name = new char[name_size]; strcpy_s(this-\u0026gt;name, name_size, name); } Person(Person\u0026amp; p) { int name_size = strlen(p.name) + 1; this-\u0026gt;id = p.id; //새로운 동적할당 this-\u0026gt;name = new char[name_size]; strcpy_s(this-\u0026gt;name, name_size, p.name); } ~Person() { delete[] name; } void show() { cout \u0026lt;\u0026lt; \u0026#34;id : \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;이름 : \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } void changeName(const char* name) { strcpy_s(this-\u0026gt;name, strlen(name) + 1, name); } }; int main(void) { Person father(1, \u0026#34;Kitae\u0026#34;); Person dauthor(father); father.show(); dauthor.show(); dauthor.changeName(\u0026#34;grace\u0026#34;); dauthor.show(); return 0; } 예제 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; using namespace std; class Book { int price; int pages; char* title; char* author; public: Book(int pr, int pa, const char* t, const char* a) { int title_size = strlen(t) + 1; int author_size = strlen(a) + 1; price = pr; pages = pa; title = new char[title_size]; strcpy_s(title, title_size, t); author = new char[author_size]; strcpy_s(author, author_size, a); } Book(Book\u0026amp; b) { price = b.price; pages = b.pages; title = new char[strlen(b.title) + 1]; strcpy_s(title, strlen(b.title) + 1, b.title); author = new char[strlen(b.author) + 1]; strcpy_s(author, strlen(b.author) + 1, b.author); } ~Book() { delete[]title; delete[]author; } void ShowBook() { cout \u0026lt;\u0026lt; \u0026#34;가격 : \u0026#34; \u0026lt;\u0026lt; price \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;페이지 : \u0026#34; \u0026lt;\u0026lt; pages \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;제목 : \u0026#34; \u0026lt;\u0026lt; title \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;저자 : \u0026#34; \u0026lt;\u0026lt; author \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } void ChangeTitle(const char* t) { delete[]title; title = new char[strlen(t) + 1]; strcpy_s(title, strlen(t) + 1, t); } void ChangeAuthor(const char* a) { delete[] author; author = new char[strlen(a) + 1]; strcpy_s(author, strlen(a) + 1, a); } }; int main(void) { Book cpp(20000, 400, \u0026#34;명품c++\u0026#34;, \u0026#34;황기태\u0026#34;); Book cplusplus(cpp); cpp.ShowBook(); cplusplus.ShowBook(); cplusplus.ChangeTitle(\u0026#34;씨플러스플러스\u0026#34;); cplusplus.ChangeAuthor(\u0026#34;박상규\u0026#34;); cplusplus.ShowBook(); return 0; } ","date":"2023-09-25T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-function-reference-copy-constructor/","title":"5. 함수와 참조, 복사 생성자"},{"content":"\r#\r객체 포인터\r객체의 주소 값을 가지는 변수\n포인터로 멤버를 접근할 때 : 객체포인터 -\u0026gt; 멤버\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 3; } Circle(int r) { radius = r; } double getArea() { return radius * radius * 3.14; } }; int main(void) { Circle donut; Circle* p = \u0026amp;donut; //객체에 대한 포인터 선언 및 객체 주소 저장 cout \u0026lt;\u0026lt; \u0026#34;using pointer : \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;getArea() \u0026lt;\u0026lt; endl; //멤버 함수 호출 cout \u0026lt;\u0026lt; \u0026#34;using *p : \u0026#34;\u0026lt;\u0026lt;(*p).getArea() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;using parameter : \u0026#34; \u0026lt;\u0026lt; donut.getArea() \u0026lt;\u0026lt; endl; return 0; } #\r객체 배열\r객체 포인터와 연결할 수 있음 객체의 멤버를 원하는 값으로 바꾸는 방법(void 생성자 호출 밖에 안됨) set() 멤버함수 구현하여 멤버변수값 변경 임시객체로 초기화 2차원 객체 배열 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { int radius; public: Circle() {radius = 3;} //void 생성자가 없다면 객체 배열 생성 시 에러가 발생한다. Circle(int r) { radius = r; } double getArea() { return radius * radius * 3.14; } void setRadius(int r) { //set() 멤버함수 구현 radius = r; } }; int main(void) { Circle arr[5]; Circle arr2[5] = { Circle(3), Circle(2), Circle(1), Circle(), Circle()}; //임시 객체로 초기화 Circle* p = arr; //배열의 이름이 포인터를 의미하기 때문에 이렇게 코드를 작성할 수 있다. arr[2].setRadius(4); //멤버변수의 값을 4로 변경 cout \u0026lt;\u0026lt; arr2[1].getArea() \u0026lt;\u0026lt; endl; //배열명으로 접근 cout \u0026lt;\u0026lt; p[1].getArea() \u0026lt;\u0026lt; endl; //포인터로 접근 cout \u0026lt;\u0026lt; (p + 2)-\u0026gt;getArea() \u0026lt;\u0026lt; endl; //화살표 연산자로 접근 cout \u0026lt;\u0026lt; (*(p + 3)).getArea() \u0026lt;\u0026lt; endl; //주소로 접근 return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 //#. 2차원 배열 int main(void) { Circle arr[2][3] = { {Circle(1), Circle(2), Circle(3)},{Circle(4), Circle(5), Circle(6)}}; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { cout \u0026lt;\u0026lt; arr[i][j].getArea() \u0026lt;\u0026lt; endl; } } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //#실습 #include \u0026lt;iostream\u0026gt; using namespace std; class Sample { int a; public: Sample() { a = 100; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } Sample(int x) { a = x; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } Sample(int x, int y) { a = x * y; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int get() { return a; } }; int main(void) { Sample arr[3]; Sample arr2D[2][2] = { {Sample(2,3), Sample(2, 4)},{Sample(5), Sample()}}; Sample* p = arr; int total = 0; int total2D = 0; for (int i = 0; i \u0026lt; 3; i++) { total += (p + i)-\u0026gt;get(); } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;첫번째 배열의 합은 \u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { total2D += arr2D[i][j].get(); } } cout \u0026lt;\u0026lt; \u0026#34;두번째 배열의 합은\u0026#34; \u0026lt;\u0026lt; total2D \u0026lt;\u0026lt; endl; return 0; } #\r동적 메모리 할당 및 반환\r#\rnew / delete 키워드\rnew / delete 키워드를 통해 동적할당이 가능하다.\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { char* cp = new char[4]; delete cp; return 0; } 1. 변수 동적 할당\n1 2 3 4 5 6 7 8 9 //C style int* p = (int *)malloc(sizeof(int)); *p = 10; free(p); //C++ style int* p = new int; *p = 10; delete p; 2. 배열 동적 할당\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //C style int* p = (int*)malloc(sizeof(int)*5); free(p); //C++ style int* p = new int[5]; delete [] p; char* p = new char[20]; delete [] p; //값 할당하기 p[i] = 10; *(p + i) = 20; #. SIZE를 입력받아서 SIZE에 해당하는 배열 동적 할당\n1 2 3 int size; cin \u0026gt;\u0026gt; size; int* p = new int[size]; #. company라는 문자열을 입력 받아 길이에 딱 맞는 배열을 동적 할당\n1 2 int size = strlen(\u0026#34;company\u0026#34;) + 1; char* p = new char[size]; 정적 할당 변수 선언을 통해 필요한 메모리 할당, 많은 양의 메모리는 배열 선언을 통해 할당 동적 할당 필요한 양이 예측되지 않는 경우. 프로그램 작성 시 할당받을 수 없음. 실행 중에 운영체제로부터 할당 받음(heap으로부터 할당) C언어의 동적 메모리 할당 malloc(), free() 라이브러리 함수 사용 -의 동적 메모리 할당/반환 new, delete 연산자 사용 #. 클래스의 경우 동적 생성이라고도 표현한다.\n#. delete 사용시 주의점\n1 2 3 4 5 6 7 8 int n = 10; int* p = \u0026amp;n; delete p; //동적할당이 된 것이 아니므로 에러 발생 int* p = new int; delete p; delete p; //이미 할당이 해제되어 에러 발생 #\r동적 할당 예시\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { int size; double sum = 0; cout \u0026lt;\u0026lt; \u0026#34;입력할 정수의 개수는 ? \u0026#34;; cin \u0026gt;\u0026gt; size; int* p = new int[size]; for (int i = 0; i \u0026lt; size; i++) { cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;번째 정수 입력 : \u0026#34;; cin \u0026gt;\u0026gt; p[i]; sum += p[i]; } delete[] p; cout \u0026lt;\u0026lt; \u0026#34;평균 : \u0026#34; \u0026lt;\u0026lt; sum / size \u0026lt;\u0026lt; endl; } #\r객체의 동적할당\r1. 객체의 멤버변수를 동적할당할 때는 소멸자에서 메모리를 해제해야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; using namespace std; // 객체의 멤버변수가 동적할당된 메모리의 주소를 지님 // 객체 생성 시 생성자에서 동적할당 // 객체가 소멸될 때 호출되는 소멸자에서 메모리 해제 class NameCard { char* name; char* comp; char* tel; char* pos; public: NameCard(const char* _name, const char* _comp, const char* _tel, const char* _pos) { int name_size = strlen(_name) + 1; int comp_size = strlen(_comp) + 1; int tel_size = strlen(_tel) + 1; int pos_size = strlen(_pos) + 1; name = new char[name_size]; strcpy_s(name, name_size, _name); comp = new char[comp_size]; strcpy_s(comp, comp_size, _comp); tel = new char[tel_size]; strcpy_s(tel, tel_size, _tel); pos = new char[pos_size]; strcpy_s(pos, pos_size, _pos); } ~NameCard() { delete[] name; delete[] comp; delete[] tel; delete[] pos; } void ShowNameCardInfo() { cout \u0026lt;\u0026lt; \u0026#34;이름 : \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;회사 : \u0026#34; \u0026lt;\u0026lt; comp \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;전화 : \u0026#34; \u0026lt;\u0026lt; tel \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;직급 : \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } }; int main(void) { NameCard manClerk(\u0026#34;Lee\u0026#34;, \u0026#34;ABCEng\u0026#34;, \u0026#34;010-000-444\u0026#34;, \u0026#34;clerk\u0026#34;); NameCard manSenior(\u0026#34;Hong\u0026#34;, \u0026#34;OrangeEng\u0026#34;, \u0026#34;010-333-4444\u0026#34;, \u0026#34;senior\u0026#34;); NameCard manAssist(\u0026#34;Kim\u0026#34;, \u0026#34;SoGoodComp\u0026#34;, \u0026#34;010-555-6666\u0026#34;, \u0026#34;assist\u0026#34;); manClerk.ShowNameCardInfo(); manSenior.ShowNameCardInfo(); manAssist.ShowNameCardInfo(); return 0; } 2. 객체 자체를 동적할당 할 경우 : main함수에서 메모리를 해제해줘야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; } Circle(int r) { radius = r; } double getArea() { return 3.14 * radius * radius; } }; int main(void) { //원의 반지름을 반복적으로 입력받아 Circle 객체 동적 생성하고 면적 출력 //음수가 입력되면 종료 int r; while (1) { cout \u0026lt;\u0026lt; \u0026#34;정수 반지름 입력(음수 입력 시 종료)\u0026#34;; cin \u0026gt;\u0026gt; r; if (r \u0026lt; 0) break; //객체 동적 생성 Circle* p = new Circle(r); cout \u0026lt;\u0026lt; \u0026#34;원의 면적은 : \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;getArea() \u0026lt;\u0026lt; endl; delete p; } return 0; } 3. 객체 배열을 동적 생성할 때 : 역시 main함수에서 메모리 해제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; } Circle(int r) { radius = r; } double getArea() { return 3.14 * radius * radius; } void setRadius(int _radius) { radius = _radius; } }; int main(void) { int n, rad; int cnt = 0; cout \u0026lt;\u0026lt; \u0026#34;생성하고자 하는 원의 개수 : \u0026#34;; cin \u0026gt;\u0026gt; n; Circle* p = new Circle[n]; for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; \u0026#34;원\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;의 반지름 : \u0026#34;; cin \u0026gt;\u0026gt; rad; p[i].setRadius(rad); // *p[0].setRadius(10); // (p + 1)-\u0026gt;setRadius(20); if (p[i].getArea() \u0026gt;= 100 \u0026amp;\u0026amp; p[i].getArea() \u0026lt;= 200) cnt++; } cout \u0026lt;\u0026lt; \u0026#34;면적이 100에서 200 사이인 원의 개수는 \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;개 입니다.\u0026#34; \u0026lt;\u0026lt; endl; delete[] p; return 0; } #\rthis 포인터\r자기참조 포인터(객체 안에서), 객체의 주소값을 가지는 변수 클래스의 멤버 함수 내에서만 사용 개발자가 선언하는 변수가 아니고, 컴파일러가 선언한 변수 멤버 함수에 컴파일러에 의해 묵시적으로 삽입 선언되는 매개 변수 #\r멤버변수와 매개변수가 변수명이 같을 때\r매개변수의 우선순위가 높기 때문에 멤버변수를 초기화할 수 없다. 이 때, 멤버변수를 this를 통해 접근할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using std; class Circle { int radius; public: Circle() { radius = 1; } Circle(int radius) { this-\u0026gt;radius = radius; } double getArea() { return 3.14 * radius * radius; } void setRadius(int radius) { this-\u0026gt;radius = radius; } }; int main(void) { Circle waffle(30); cout \u0026lt;\u0026lt; waffle.getArea() \u0026lt;\u0026lt; endl; return 0; } #\r멤버 함수가 객체 자신의 주소를 반환할 때\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { int radius; public: Circle() { radius = 1; } Circle(int radius) { this-\u0026gt;radius = radius; } double getArea() { return 3.14 * radius * radius; } void setRadius(int _radius) { radius = _radius; } Circle* increase() { radius++; return this; } Circle decrease() { radius--; return *this; } }; int main(void) { Circle pizza; pizza.setRadius(10); cout \u0026lt;\u0026lt; pizza.getArea() \u0026lt;\u0026lt; endl; Circle* p = pizza.increase(); cout \u0026lt;\u0026lt; p-\u0026gt;getArea() \u0026lt;\u0026lt; endl; Circle tmp = pizza.decrease(); cout \u0026lt;\u0026lt; tmp.getArea() \u0026lt;\u0026lt; endl; return 0; } #\r제약사항\r멤버 함수가 아닌 함수에서 this 사용 불가 객체와의 관련성이 없기 때문 static 멤버 함수에서 this 사용 불가 객체가 생기기 전에 static 함수 호출이 있을 수 있기 때문에 #\rstring 클래스\r문자열 처리를 위한 클래스이다. string은 객체이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;string\u0026gt; int main(void) { // 1. 생성 string name = \u0026#34;kim\u0026#34;; string yourname(name); string yourname1 = name; string addr(\u0026#34;서울 서초구 양재동\u0026#34;); // 2. 출력 cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; endl; // 3. 동적 생성 string* ptr = new string(\u0026#34;C++\u0026#34;); delete ptr; // 4. 입력 cin \u0026gt;\u0026gt; addr; getline(cin, addr); } # string 클래스 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // string배열에 5개의 문자열을 받고, 사전 구성에서 가장 뒤에 오는 문자열 출력 int main(void) { string arr[5]; for (int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; \u0026#34;이름 \u0026gt;\u0026gt; \u0026#34;; getline(cin, arr[i]); } // 최대값 구하기 string max = arr[0]; for (int i = 0; i \u0026lt; 5; i++) { if (max \u0026lt; arr[i]) { max = arr[i]; } } cout \u0026lt;\u0026lt; \u0026#34;사전에서 가장 뒤에 나오는 문자열은 \u0026#34; \u0026lt;\u0026lt; max \u0026lt;\u0026lt; endl; return 0; } #\r문자열을 다루기 위한 멤버함수(string 클래스)\r문자열 비교\nint compare(string \u0026amp; str) : 문자열과 str을 비교해서 같으면 0, str보다 앞에 있으면 음수, 뒤에 있으면 양수\n비교연산 : \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=, = 문자열 연결\nappend() 함수 사용가능 문자열 삽입\ninsert(인덱스, 문자열) 함수 사용 문자열 바꾸기(치환)\nreplace(위치, 몇 개, \u0026ldquo;바꿀 문자열\u0026rdquo;) 함수 사용 문자열 길이 구하기\nlength() 함수, size() 함수 문자열 지우기\nerase(위치, 몇개) 함수 문자열 추출\nsubstr(위치, 몇개) 함수 문자 찾기\nfind(문자열) : 찾으면 위치 반환, 못 찾으면 -1 반환 문자를 숫자로 바꾸기\nstoi() 함수 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(void) { // 1. 문자열 비교 string str1 = \u0026#34;kim\u0026#34;; string str2 = \u0026#34;lee\u0026#34;; if (str1.compare(str2) == 0) cout \u0026lt;\u0026lt; \u0026#34;같다\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;아니다\u0026#34; \u0026lt;\u0026lt; endl; // 2. 문자열 연결 string str3 = \u0026#34;서울\u0026#34;; string str4 = \u0026#34; 양재동\u0026#34;; str3.append(\u0026#34; 서초구\u0026#34;); cout \u0026lt;\u0026lt; str3 \u0026lt;\u0026lt; endl; string addr = str3 + str4; cout \u0026lt;\u0026lt; addr \u0026lt;\u0026lt; endl; // 3. 문자열 삽입 string str5 = \u0026#34;I love C++\u0026#34;; str5.insert(2, \u0026#34;really \u0026#34;); cout \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; // 4. 문자열 바꾸기(치환) str5.replace(2, 11, \u0026#34;study\u0026#34;); cout \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; // 5. 문자열 길이 cout \u0026lt;\u0026lt; str5.length() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; str5.size() \u0026lt;\u0026lt; endl; // 6. 문자열 지우기 str5.erase(0, 8); cout \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; str5.clear(); cout \u0026lt;\u0026lt; str5 \u0026lt;\u0026lt; endl; // 7. 문자열 추출 string str6(\u0026#34;I love C++\u0026#34;); string tmp = str6.substr(2, 4); string tmp1 = str6.substr(2); cout \u0026lt;\u0026lt; str6 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmp1 \u0026lt;\u0026lt; endl; // 8. 문자 찾기 int result = str6.find(\u0026#34;love\u0026#34;); cout \u0026lt;\u0026lt; str6.find(\u0026#34;love\u0026#34;) \u0026lt;\u0026lt; endl; result = str6.find(\u0026#34;LOVE\u0026#34;); cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; // 9. string to integer string year = \u0026#34;2023\u0026#34;; int n = stoi(year); cout \u0026lt;\u0026lt; typeid(n).name() \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Person { string name; string tel; public: string getName() { return name; } string getTel() { return tel; } void SetPerson(string name, string tel) { this-\u0026gt;name = name; this-\u0026gt;tel = tel; } }; int main(void) { Person people[3]; string name, tel; cout \u0026lt;\u0026lt; \u0026#34;사람이름 번호 순으로 입력하세요(공백으로 구분)\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 3; i++) { cout \u0026lt;\u0026lt; \u0026#34;사람 1 \u0026gt;\u0026gt; \u0026#34;; cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; tel; people[i].SetPerson(name, tel); } cout \u0026lt;\u0026lt; \u0026#34;모든 사람의 이름은 \u0026#34;; for (int i = 0; i \u0026lt; 3; i++) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; people[i].getName(); } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;전화번호를 검색합니다. 이름을 입력해주세요 \u0026#34;; cin \u0026gt;\u0026gt; name; for (int i = 0; i \u0026lt; 3; i++) { if (name == people[i].getName() ){ cout \u0026lt;\u0026lt; people[i].getTel() \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2023-09-11T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-op-array-da/","title":"4. 객체 포인터, 배열, 동적 생성"},{"content":"\r#\r캡슐화\r객체의 본질적인 특성 객체를 캡슐화해서 내부를 보호하고 볼 수 없게 함(정보은닉) 외부와 인터페이스를 위해 객체의 일부분만 공개 객체는 상태(state)와 행동(behavior)으로 구성되는데, TV를 예시로 들면 상태는 on/off 속성, 채널, 음량 등이 있고 행동으로는 켜기/끄기, 채널 증가 감소, 음량 증가 감소 등이 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TV { private: bool isOn; int channel; int volume; public: void poweron(){} void poweroff(){} void increaseChannel(){} void decreaseChannel(){} void increaseVolume(){} void decreaseVolume(){} } //----------------------------------------------- TV myTv; TV yourTv; myTv.increaChannel(); yourTv.decreaseVolume(); //외부에서 데이터 접근하려면 메소드 통해서 해야함 // private안에 있는 애들은 은닉되어있음 // myTv.channel = 5; 이런식으론 안됨 #\r클래스 작성\r클래스는 멤버변수와 멤버함수로 구성되고, 클래스 선언부와 클래스 구현부가 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 class AAA { public: int aaa; void MyFunc(); } void AAA::MyFunc() { aaa++; } 멤버변수는 클래스 안에서 초기화 시킬 수 없음\n멤버함수는 원형 형태로 선언하며 멤버에 대한 접근 권한을 지정함\nprivate, public, protected중의 하나(디폴트는 private)\nprivate : 내부 접근\npublic : 다른 모든 클래스나 객체에서 멤버의 접근이 가능함\nprotected : 내부와 자식에서 접근\n#\r객체 만들기\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; // 원클래스 (반지름, 원넓이) class Circle { public: int radius; double getArea(); }; // 선언 이후 따로 구현 double Circle::getArea() { return radius * radius * 3.14; } int main(void) { Circle doughnut; doughnut.radius = 3; cout \u0026lt;\u0026lt; \u0026#34;도넛의 면적은 \u0026#34; \u0026lt;\u0026lt; doughnut.getArea()\u0026lt;\u0026lt;endl; Circle pizza; pizza.radius = 10; cout \u0026lt;\u0026lt; \u0026#34;피자의 면적은 \u0026#34; \u0026lt;\u0026lt; pizza.getArea()\u0026lt;\u0026lt;endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class Calendar { public: int year; int month; int day; int getYear() { return year; } int getMonth() { return month; } int getDay() { return day; } }; int main() { Calendar today; today.year = 2023; today.month = 9; today.day = 4; cout \u0026lt;\u0026lt; \u0026#34;오늘은 \u0026#34; \u0026lt;\u0026lt; today.getYear() \u0026lt;\u0026lt; \u0026#34;년 \u0026#34; \u0026lt;\u0026lt; today.getMonth() \u0026lt;\u0026lt; \u0026#34;월 \u0026#34; \u0026lt;\u0026lt; today.getDay() \u0026lt;\u0026lt; \u0026#34;일입니다.\u0026#34; \u0026lt;\u0026lt; endl; } #\r생성자(Constructor)\r객체 생성시 반드시 한번 호출되는 함수이다.\n클래스명과 동일한 함수명으로 작성 반환형이 없고 반환하지 않는다. 함수 오버로딩 가능(매개변수만 다르면 중복해서 선언 가능) 구현을 하지 않으면 컴파일러에 의해서 default 생성자 삽입 / 호출된다.\n클래스명(){} // body 비어 있고 매개변수도 없음 객체 생성과 동시에 원하는 값으로 멤버를 초기화시킬 수 있음 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; // 원클래스 (반지름, 원넓이) class Circle { //private: //안써도 디폴트 int radius; public: double getArea(); //생성자 (클래스이름하고 같음), 오버로딩 가능 Circle() { radius = 3; } Circle(int r) { radius = r; } }; // 선언 이후 따로 구현 double Circle::getArea() { return radius * radius * 3.14; } int main(void) { Circle doughnut; cout \u0026lt;\u0026lt; \u0026#34;도넛의 면적은 \u0026#34; \u0026lt;\u0026lt; doughnut.getArea()\u0026lt;\u0026lt;endl; Circle pizza(10); cout \u0026lt;\u0026lt; \u0026#34;피자의 면적은 \u0026#34; \u0026lt;\u0026lt; pizza.getArea()\u0026lt;\u0026lt;endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; class Calendar { int year; int month; int day; public: int getYear() { return year; } int getMonth() { return month; } int getDay() { return day; } Calendar(int Y, int M, int D) { year = Y; month = M; day = D; } }; int main() { Calendar today(2023, 9, 4); cout \u0026lt;\u0026lt; \u0026#34;오늘은 \u0026#34; \u0026lt;\u0026lt; today.getYear() \u0026lt;\u0026lt; \u0026#34;년 \u0026#34; \u0026lt;\u0026lt; today.getMonth() \u0026lt;\u0026lt; \u0026#34;월 \u0026#34; \u0026lt;\u0026lt; today.getDay() \u0026lt;\u0026lt; \u0026#34;일입니다.\u0026#34; \u0026lt;\u0026lt; endl; } #\r소멸자(Destructor)\r생성자와 반대로 객체가 소멸될 때 반드시 한번 호출되는 함수이다.\n클래스명 앞에 ~를 붙인 함수명( ex : ~Rectangle() ) 반환형이 없고 반환하지 않음 매개변수 없음 \u0026raquo; 함수 오버로딩 X 구현을 하지 않으면 컴파일러에 의해서 default 소멸자 삽입/호출 객체 소멸 시 할 일이 있다면 구현하고 대부분의 경우 구현 안 해도 됨. 소멸자가 호출되면 메모리 공간이 소멸된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { public: int radius; Circle(); Circle(int r); ~Circle(); // 소멸자 double getArea(); }; Circle::Circle() { radius = 1; cout \u0026lt;\u0026lt; \u0026#34;반지름 \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; \u0026#34; 원 생성\u0026#34; \u0026lt;\u0026lt; endl; } Circle::Circle(int r) { radius = r; cout \u0026lt;\u0026lt; \u0026#34;반지름 \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; \u0026#34; 원 생성\u0026#34; \u0026lt;\u0026lt; endl; } Circle::~Circle() { cout \u0026lt;\u0026lt; \u0026#34;반지름 \u0026#34; \u0026lt;\u0026lt;radius \u0026lt;\u0026lt; \u0026#34; 원 소멸\u0026#34; \u0026lt;\u0026lt; endl; } double Circle::getArea() { return 3.14*radius*radius; } int main() { Circle donut; Circle pizza(30); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; class Calculator { private: int addcnt; int mincnt; int divcnt; int mulcnt; public: Calculator() { addcnt = 0; mincnt = 0; divcnt = 0; mulcnt = 0; }; int Add(int a, int b) { addcnt++; return a + b; }; int Min(int a, int b) { mincnt++; return a - b; }; float Div(float a, float b) { divcnt++; return a / b; }; int Mul(int a, int b) { mulcnt++; return a * b; }; void ShowOPCount(){ cout \u0026lt;\u0026lt; \u0026#34;덧셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; addcnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;뺄셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; mincnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;나눗셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; divcnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;곱셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; mulcnt \u0026lt;\u0026lt; endl; } }; int main(void) { Calculator cal; cout \u0026lt;\u0026lt; \u0026#34;3+5 = \u0026#34; \u0026lt;\u0026lt; cal.Add(3, 5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3/5 = \u0026#34; \u0026lt;\u0026lt; cal.Div(3, 5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;12-4 = \u0026#34; \u0026lt;\u0026lt; cal.Min(12, 4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;12/4 = \u0026#34; \u0026lt;\u0026lt; cal.Div(12, 4) \u0026lt;\u0026lt; endl; cal.ShowOPCount(); return 0; } #\r추가 내용\r#\r바람직한 C++ 프로그램 작성법\r클래스를 헤더 파일과 cpp파일로 분리하여 작성\n클래스마다 분리 저장 클래스 선언 부 : 헤더 파일에 저장 클래스 구현 부 : cpp 파일에 저장, 클래스가 선언된 헤더 파일 include 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //2.cpp #include \u0026#34;2.h\u0026#34; int main(void) { Calculator cal; cout \u0026lt;\u0026lt; \u0026#34;3+5 = \u0026#34; \u0026lt;\u0026lt; cal.Add(3, 5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3/5 = \u0026#34; \u0026lt;\u0026lt; cal.Div(3, 5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;12-4 = \u0026#34; \u0026lt;\u0026lt; cal.Min(12, 4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;12/4 = \u0026#34; \u0026lt;\u0026lt; cal.Div(12, 4) \u0026lt;\u0026lt; endl; cal.ShowOPCount(); return 0; } class Point { int x; //여기에 바로 const를 선언해버리면 생성자 함수를 호출할 때 에러가 발생한다. int y; public: Point(int _x, int _y) { x = _x; y = _y; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //2.h #pragma once #include \u0026lt;iostream\u0026gt; using namespace std; class Calculator { private: int addcnt; int mincnt; int divcnt; int mulcnt; public: Calculator() { addcnt = 0; mincnt = 0; divcnt = 0; mulcnt = 0; }; int Add(int a, int b) { addcnt++; return a + b; }; int Min(int a, int b) { mincnt++; return a - b; }; float Div(float a, float b) { divcnt++; return a / b; }; int Mul(int a, int b) { mulcnt++; return a * b; }; void ShowOPCount() { cout \u0026lt;\u0026lt; \u0026#34;덧셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; addcnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;뺄셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; mincnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;나눗셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; divcnt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;곱셈 계산횟수는 \u0026#34; \u0026lt;\u0026lt; mulcnt \u0026lt;\u0026lt; endl; } }; #\r멤버 이니셜라이저(멤버 초기자)\r멤버변수 초기화 시 사용 const변수(상수)는 이니셜라이저를 통해 초기화가 이루어져야 함 #1 이니셜라이저는 생성자 몸체부분 호출 전에 실행 멤버변수로 사용된 객체의 생성자 호출에 사용 #2 상속 관계에서 자주 사용됨 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //#1. #include \u0026lt;iostream\u0026gt; using namespace std; class Point { const int x; //여기에 바로 const를 선언해버리면 생성자 함수를 호출할 때 에러가 발생한다. int y; public: Point(int _x, int _y）{ x = _x; y = _y; } void ShowPos() { cout \u0026lt;\u0026lt; \u0026#34;x : \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;y : \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } }; //----------------------------------------------------------- class Point { const int x; int y; public: Point(int _x, int _y) : x(_x) { //멤버 이니셜라이저를 사용하여 초기화하며 const적용 y = _y; } void ShowPos() { cout \u0026lt;\u0026lt; \u0026#34;x : \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;y : \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //#2. 다른 클래스의 객체가 멤버변수일 때 초기화 하기 위해 사용 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { int x; int y; public: Point(int _x, int _y){ x = _x; y = _y; } void ShowPos() { cout \u0026lt;\u0026lt; \u0026#34;x : \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;y : \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } }; class Rectangle { Point lefttop; Point rightbottom; public: Rectangle(int left, int top, int right, int bottom):lefttop(left,top),rightbottom(right,bottom) { //lefttop.x = left 는 잘못된 코드이다. //Point클래스의 생성자에서 x,y를 초기화 할 수 있도록 구현해야한다. }; void ShowRec() { cout \u0026lt;\u0026lt; \u0026#34;[좌상단]\u0026#34; \u0026lt;\u0026lt; endl; lefttop.ShowPos(); cout \u0026lt;\u0026lt; \u0026#34;[우하단]\u0026#34; \u0026lt;\u0026lt; endl; rightbottom.ShowPos(); } }; int main(void) { Rectangle rec(10, 10, 100, 100); rec.ShowRec(); return 0; } ","date":"2023-09-05T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-class-instance/","title":"3. 클래스와 객체"},{"content":"\r#\rC++의 출력\rC++은 C와 다르게 데이터 타입 formating이 필요 없다.\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; int main(void) { std::cout \u0026lt;\u0026lt; \u0026#34;이름 : 홍길동\u0026#34;\u0026lt;\u0026lt;std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;나이 : 26\u0026#34;\u0026lt;\u0026lt;std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;학과 : 소프트웨어공학\u0026#34;\u0026lt;\u0026lt;std::endl; return 0; } iostream 헤더 파일 ios, istream, ostream 클래스 등 표준 입출력을 위한 클래스와 객체, 변수 등이 선언됨.\n입력을 위한 cout, cin, \u0026laquo;, \u0026raquo;, endl 등 선언\nstd::cout\u0026lt;\u0026lt;\u0026quot;HelloWorld\u0026quot;; iostream의 std안에 정의된 cout 객체 호출.\n:: 네임스페이스에 정의된 이름에 접근하기 위해 사용\ncout 객체(console out) 스크린 출력 장치에 연결된 표준 C++ 출력 스트림 객체\n\u0026lt;\u0026lt; 출력스트림연산자, 오른쪽 피연산자를 왼쪽 스트림 객체에 삽입\nendl 지시자(개행, 출력버퍼값을 초기화해 준다)\n#\r네임스페이스(namespace)\r같은 이름으로 정의된 경우 발생하는 충돌을 해결하기 위해 사용하며, ::를 이용하여 접근한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace one{ int f(){ return 0; } } namespace two{ int f(){ return 1; } } two::f(); #\r네임스페이스 간단하게 접근하기(using)\r1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; // 네임스페이스를 간단하게 접근 int main(void) { cout \u0026lt;\u0026lt; \u0026#34;실제로 작동하는지 확인\u0026#34;\u0026lt;\u0026lt;endl; return 0; } #\rC++의 입력\rcin을 사용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //std 간단하게 호출 double getArea(int a) { int radius = a; return radius * radius * 3.14; } int main(void) { int radius; int radius2; cout \u0026lt;\u0026lt; \u0026#34;원의 반지름 : \u0026#34;; cin \u0026gt;\u0026gt; radius; cout \u0026lt;\u0026lt; \u0026#34;원의 넓이 : \u0026#34; \u0026lt;\u0026lt; getArea(radius) \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; radius \u0026gt;\u0026gt; radius2; //연속으로 입력 받을 수 있다. enter, space, tab 으로 구분한다. return 0; } #\rcin 문장 입력받기(space 포함하여 값 받기)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main(void) { char name[20]; int age; char dept[20]; cout \u0026lt;\u0026lt; \u0026#34;이름, 나이, 학과 순으로 입력하세요(엔터로 구분)\u0026#34;\u0026lt;\u0026lt;endl; cin.getline(name, 20, \u0026#39;\\n\u0026#39;); cin.ignore(); //clear(); cin \u0026gt;\u0026gt; age; cin.ignore(); //입력 버퍼값을 비워줘야 getline에 제대로 값을 입력받을 수 있다. cin.getline(dept, 20, \u0026#39;\\n\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;이름 : \u0026#34;\u0026lt;\u0026lt;name\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;나이 : \u0026#34;\u0026lt;\u0026lt;age\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;학과 : \u0026#34;\u0026lt;\u0026lt;dept\u0026lt;\u0026lt;endl; return 0; } #\rstring 클래스 이용하여 문자열 다루기\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;string\u0026gt; string str; // str = \u0026#34;test\u0026#34;; string str(\u0026#34;test\u0026#34;); string str1 = \u0026#34;test\u0026#34;; string str2 = str1; string addr; cin\u0026gt;\u0026gt;addr; // space tab enter 받으면 끝나버림 // cin.getline(addr, 20); \u0026lt;- 이건 배열에 받는 방식, string객체는 이렇게 못 받음 // string 자체에 getline이 있음 cin.getline하지말고 getline(cin, addr); // enter를 입력하면 cin객체에서 문자열을 추출해서 addr객체에 저장 cin.ignore(); // buffer clear ","date":"2023-08-29T00:00:03Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-io/","title":"2. C++의 입출력"},{"content":"\r#\rC++언어의 주요한 설계 목적\r캡슐화(클래스) : 데이터를 캡슐로 싸서 외부의 접근으로부터 보호(정보은닉), 멤버 변수와 멤버 함수 이용\nprivate 변수의 초기화, 조회 등에는 생성자 함수, public 함수 등을 이용하여 private에 접근한다. 상속 : 객체가 자식 클래스의 멤버와 부모 클래스에 선언된 모양 그대로 멤버들을 가지고 탄생한다. 객체간 IS-A 관계가 성립되어야 한다. 재사용성에 강점이 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Person { public: void sleep(){}; }; class Student : public Person //Student 는 Person의 특징을 상속받는다. { public: void study(){}; }; Student s1; s1.sleep(); //실행 가능 #\rC++의 특징\r#\r함수중복(Function Overloading) - 다형성\r매개변수 정보가 다르면 함수 이름을 중복해서 선언할 수 있다.\n다형성 : 하나의 기능이 경우에 따라 다르게 보이거나 다르게 작동한다. 연산자 중복, 함수 중복, 함수 재정의(overriding)\n1 2 3 4 5 6 7 8 int sum(int a, int b){ return a+b; } int sum(int a, int b, int c){ return a+b+c; } #\r디폴트 매개 변수(default parameter)\r함수를 정의할 때 매개변수에 기본값을 지정할 수 있다. 이는 overloading과도 이어진다.\n1 2 3 4 5 6 7 8 9 int sum(int a = 0, int b = 10) { return a+b; } //메인에서 호출시 sum(10); // return 20 sum(10,20); // return 30 #\r참조와 참조 변수(reference)\r이름을 지니는 공간(변수에 할당된 공간)에 별명을 부여하는 것.\n이는 참조에 의한 호출을 위해 사용된다.\n1 2 3 4 5 int a = 10; int \u0026amp;ref = a; //자료형 \u0026amp;레퍼런스명 = 대상; Student kim; //클래스 이름과 객체 Student \u0026amp;lee = kim; #\r참조에 의한 호출(call-by-reference)\r1 2 3 4 5 6 7 8 9 10 11 12 13 //참조 변수 활용 void swap(int \u0026amp;a, int \u0026amp;b) { int tmp = a; a = b; b = tmp; } void main(void) { int x = 10, y = 20; swap(x, y); } #\rnew/delete 연산자\r동적할당 / 해제 : 메모리를 동적으로 필요한 만큼만 상황에 맞게 할당하고 해제하는 것. 메인 메모리에서는 불가하고 Heap이라는 공간에서 사용 가능, 메인 메모리에 포인터가 있어야함. 1 2 3 4 5 6 7 8 9 10 11 12 char *p = new char[4]; //메모리 공간 할당 strcpy(p, \u0026#34;kim\u0026#34;); delete [] p; //메모리 공간 해제 int *p1 = new int; *p1 = 10; delete p1; /* 일반적으로는 new char[4]와 같이 고정적으로 할당하지 않고 입력받은 문자열의 len을 받아와 그 값을 할당한다. */ #\r연산자 재정의\r기존 C++ 연산자에 새로운 연산을 정의할 수 있다.\n#\r제네릭 함수와 클래스(일반화)\r데이터 타입에 의존하지 않고 일반화시킨 함수나 클래스 작성 가능\n","date":"2023-08-23T00:00:00Z","image":"http://localhost:1313/cover/C++.png","permalink":"http://localhost:1313/article/cpp-feature/","title":"1. C++의 특징"},{"content":"\n학점은행제로 컴퓨터공학 학사를 취득하며 사용한 양식입니다.\n아래에 링크 이동 후 사본 저장한 뒤, 과목명을 적절히 수정하셔서 사용하시면 되겠습니다.\n#\r사용방법\r#\r과목 등록\r수강중인 교과목명 등록 후 이수구분(전필, 전선, 일선, 교양)을 입력하시면 현재 학점으로 합산됩니다. 전공필수와 전공선택의 과목명과 일치하는 교과목명이 있다면 초록색으로 표시됩니다. #\r자격증, 독학사 등 등록\r합격한 자격증, 시험 등은 현재 학점 아래의 주황색칸에 등록하시면 현재 학점으로 합산됩니다. #\r학점 계획\r준비중인 자격증이나 시험 등은 학점 계획 아래 주황색칸에 등록하시면 계획 학점 총합에 합산됩니다. 현재 학점과 계획 학점 총합은 계획 학점 총합 아래의 현재+계획 총합에 합산됩니다. #\r링크\r구글 스프레드시트로 이동\n","date":"2023-01-01T00:00:00Z","permalink":"http://localhost:1313/article/credit-bank-cal/","title":"학점은행제 학점 계산기 공유(학점 관리, 학점 계획)"}]